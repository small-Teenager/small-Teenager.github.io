[{"title":"Github 骚操作","url":"/2019/12/16/Github-%E9%AA%9A%E6%93%8D%E4%BD%9C/","content":"<h2 id=\"Search\"><a href=\"#Search\" class=\"headerlink\" title=\"Search\"></a>Search</h2><h3 id=\"in-限制搜索\"><a href=\"#in-限制搜索\" class=\"headerlink\" title=\"in 限制搜索\"></a>in 限制搜索</h3><p>project in:name,readme,description</p>\n<h3 id=\"stars-fork-范围搜索\"><a href=\"#stars-fork-范围搜索\" class=\"headerlink\" title=\"stars fork 范围搜索\"></a>stars fork 范围搜索</h3><p>project stars:&gt;&#x3D;5000</p>\n<p>project forks:&gt;500</p>\n<p>project forks:100..200 stars:80..100</p>\n<h3 id=\"awesome-关键字-搜索\"><a href=\"#awesome-关键字-搜索\" class=\"headerlink\" title=\"awesome + 关键字  搜索\"></a>awesome + 关键字  搜索</h3><p>awesome kafka</p>\n<h3 id=\"share-code-L\"><a href=\"#share-code-L\" class=\"headerlink\" title=\"share code #L\"></a>share code #L</h3><p>url+#L6-L10</p>\n<h3 id=\"T-项目内搜索\"><a href=\"#T-项目内搜索\" class=\"headerlink\" title=\"T 项目内搜索\"></a>T 项目内搜索</h3><p> 进入项目 按键盘T </p>\n<h3 id=\"location-搜索区域活跃用户\"><a href=\"#location-搜索区域活跃用户\" class=\"headerlink\" title=\"location 搜索区域活跃用户\"></a>location 搜索区域活跃用户</h3><p>location:beijing language:java</p>\n","tags":["Github"]},{"title":"Redis的AOF与RDB对比","url":"/2019/11/12/Redis%E7%9A%84AOF%E4%B8%8ERDB%E5%AF%B9%E6%AF%94/","content":"<p>持久化主要是做灾难恢复，数据恢复，也可以归类到高可用的一个环节里面去</p>\n<p>比如你redis整个挂了，然后redis就不可用了，你要做的事情是让redis变得可用，尽快变得可用</p>\n<p>重启redis，尽快让它对外提供服务，如果你没做数据备份，这个时候redis启动了，也不可用啊，数据都没了</p>\n<p>很可能说，大量的请求过来，缓存全部无法命中，在redis里根本找不到数据，这个时候就死定了，缓存雪崩问题，所有请求，没有在redis命中，就会去数据库这种数据源头中去找，一下子数据库承接高并发，然后就挂了<br>数据库挂掉，你都没法去找数据恢复到redis里面去，redis的数据从哪儿来？从数据库来。。。</p>\n<p>如果你把redis的持久化做好，那么即使你的redis故障了，也可以通过备份数据，快速恢复，一旦恢复立即对外提供服务</p>\n<p>redis持久化：RDB，AOF</p>\n<p><img src=\"/img/imgs/RDB%E5%92%8CAOF%E7%9A%84%E4%BB%8B%E7%BB%8D.png\">  </p>\n<h1 id=\"1、RDB和AOF两种持久化机制的介绍\"><a href=\"#1、RDB和AOF两种持久化机制的介绍\" class=\"headerlink\" title=\"1、RDB和AOF两种持久化机制的介绍\"></a>1、RDB和AOF两种持久化机制的介绍</h1><p>RDB持久化机制，对redis中的数据执行周期性的持久化</p>\n<p>AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集</p>\n<p>如果我们想要redis仅仅作为纯内存的缓存来用，那么可以禁止RDB和AOF所有的持久化机制</p>\n<p>通过RDB或AOF，都可以将redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到别的地方去，比如说阿里云，云服务</p>\n<p>如果redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务</p>\n<p>如果同时使用RDB和AOF两种持久化机制，那么在redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整</p>\n<h1 id=\"2、RDB持久化机制的优点\"><a href=\"#2、RDB持久化机制的优点\" class=\"headerlink\" title=\"2、RDB持久化机制的优点\"></a>2、RDB持久化机制的优点</h1><p>（1）RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说Amazon的S3云服务上去，在国内可以是阿里云的ODPS分布式存储上，以预定好的备份策略来定期备份redis中的数据</p>\n<p>（2）RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可</p>\n<p>（3）相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速</p>\n<pre><code>结合上述优点，RDB特别适合做冷备份，冷备\n</code></pre>\n<h1 id=\"3、RDB持久化机制的缺点\"><a href=\"#3、RDB持久化机制的缺点\" class=\"headerlink\" title=\"3、RDB持久化机制的缺点\"></a>3、RDB持久化机制的缺点</h1><p>（1）如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机，那么会丢失最近5分钟的数据</p>\n<p>（2）RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒</p>\n<h1 id=\"4、AOF持久化机制的优点\"><a href=\"#4、AOF持久化机制的优点\" class=\"headerlink\" title=\"4、AOF持久化机制的优点\"></a>4、AOF持久化机制的优点</h1><p>（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据</p>\n<p>（2）AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复</p>\n<p>（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。</p>\n<p>（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据</p>\n<h1 id=\"5、AOF持久化机制的缺点\"><a href=\"#5、AOF持久化机制的缺点\" class=\"headerlink\" title=\"5、AOF持久化机制的缺点\"></a>5、AOF持久化机制的缺点</h1><p>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大</p>\n<p>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的</p>\n<p>（3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似AOF这种较为复杂的基于命令日志&#x2F;merge&#x2F;回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</p>\n<h1 id=\"6、RDB和AOF到底该如何选择\"><a href=\"#6、RDB和AOF到底该如何选择\" class=\"headerlink\" title=\"6、RDB和AOF到底该如何选择\"></a>6、RDB和AOF到底该如何选择</h1><p>（1）不要仅仅使用RDB，因为那样会导致你丢失很多数据</p>\n<p>（2）也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug</p>\n<p>（3）综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复</p>\n","tags":["Redis"]},{"title":"SQL优化","url":"/2019/11/07/SQL%E4%BC%98%E5%8C%96/","content":"<h2 id=\"一、为什么要对SQL进行优化\"><a href=\"#一、为什么要对SQL进行优化\" class=\"headerlink\" title=\"一、为什么要对SQL进行优化\"></a>一、为什么要对SQL进行优化</h2><ul>\n<li>我们开发项目上线初期，由于业务数据量相对较少，一些SQL的执行效率对程序运行效率的影响不太明显，而开发和运维人员也无法判断SQL对程序的运行效率有多大，故很少针对SQL进行专门的优化，而随着时间的积累，业务数据量的增多，SQL的执行效率对程序的运行效率的影响逐渐增大，此时对SQL的优化就很有必要。</li>\n</ul>\n<h2 id=\"二、SQL优化的一些方法\"><a href=\"#二、SQL优化的一些方法\" class=\"headerlink\" title=\"二、SQL优化的一些方法\"></a>二、SQL优化的一些方法</h2><h3 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h3><ul>\n<li><p>1.要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</p>\n</li>\n<li><p>2.(1)在经常需要进行检索的字段上创建索引，比如要按照表字段username进行检索，那么就应该在姓名字段上创建索引，如果经常要按照员工部门和员工岗位级别进行检索，那么就应该在员工部门和员工岗位级别这两个字段上创建索引。<br>  (2)创建索引给检索带来的性能提升往往是巨大的，因此在发现检索速度过慢的时候应该首先想到的就是创建索引。<br>  (3)一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。</p>\n</li>\n</ul>\n<h3 id=\"避免在索引上使用计算\"><a href=\"#避免在索引上使用计算\" class=\"headerlink\" title=\"避免在索引上使用计算\"></a>避免在索引上使用计算</h3><ul>\n<li>在where字句中，如果索引列是计算或者函数的一部分，DBMS的优化器将不会使用索引而使用全表查询,函数<br>属于计算的一种,同时在in和exists中通常情况下使用EXISTS，因为in不走索引</li>\n</ul>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">效率低：</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">user</span> <span class=\"keyword\">where</span> salary*<span class=\"number\">22</span>&gt;<span class=\"number\">11000</span>(salary是索引列)</span><br><span class=\"line\"></span><br><span class=\"line\">效率高：</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">user</span> <span class=\"keyword\">where</span> salary&gt;<span class=\"number\">11000</span>/<span class=\"number\">22</span>(salary是索引列)</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用预编译查询\"><a href=\"#使用预编译查询\" class=\"headerlink\" title=\"使用预编译查询\"></a>使用预编译查询</h3><ul>\n<li>程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞<br>攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化<br>并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。</li>\n</ul>\n<h3 id=\"调整Where字句中的连接顺序\"><a href=\"#调整Where字句中的连接顺序\" class=\"headerlink\" title=\"调整Where字句中的连接顺序\"></a>调整Where字句中的连接顺序</h3><p>DBMS一般采用自下而上的顺序解析where字句，根据这个原理表连接最好写在其他where条件之前，那些可以<br>过滤掉最大数量记录。</p>\n<h3 id=\"用where字句替换HAVING字句\"><a href=\"#用where字句替换HAVING字句\" class=\"headerlink\" title=\"用where字句替换HAVING字句\"></a>用where字句替换HAVING字句</h3><ul>\n<li>避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前<br>刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数<br>的过滤，除此之外，应该将条件写在where字句中。</li>\n</ul>\n<h3 id=\"使用表的别名\"><a href=\"#使用表的别名\" class=\"headerlink\" title=\"使用表的别名\"></a>使用表的别名</h3><ul>\n<li>当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减<br>少哪些友列名歧义引起的语法错误。</li>\n</ul>\n<h3 id=\"用union-all替换union\"><a href=\"#用union-all替换union\" class=\"headerlink\" title=\"用union all替换union\"></a>用union all替换union</h3><ul>\n<li>当SQL语句需要union两个查询结果集合时，即使检索结果中不会有重复的记录，如果使用union这两个结果集<br>同样会尝试进行合并，然后在输出最终结果前进行排序，因此如果可以判断检索结果中不会有重复的记录时候，应<br>该用union all，这样效率就会因此得到提高。</li>\n</ul>\n<h3 id=\"尽量避免使用游标\"><a href=\"#尽量避免使用游标\" class=\"headerlink\" title=\"尽量避免使用游标\"></a>尽量避免使用游标</h3><ul>\n<li>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>\n</ul>\n<h3 id=\"用varchar-nvarchar-代替-char-nchar\"><a href=\"#用varchar-nvarchar-代替-char-nchar\" class=\"headerlink\" title=\"用varchar&#x2F;nvarchar 代替 char&#x2F;nchar\"></a>用varchar&#x2F;nvarchar 代替 char&#x2F;nchar</h3><ul>\n<li>尽可能的使用 varchar&#x2F;nvarchar 代替 char&#x2F;nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。<br>不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。</li>\n</ul>\n<h3 id=\"查询select语句优化\"><a href=\"#查询select语句优化\" class=\"headerlink\" title=\"查询select语句优化\"></a>查询select语句优化</h3><figure class=\"highlight n1ql\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1.任何地方都不要使用 <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> t ，用具体的字段列表代替“*”，不要返回用不到的任何字段</span><br><span class=\"line\"><span class=\"number\">2.</span>应尽量避免在 <span class=\"keyword\">where</span> 子句中对字段进行 <span class=\"literal\">null</span> 值判断，否则将导致引擎放弃使用索引而进行全表扫描，</span><br><span class=\"line\">如：</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> id <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> num <span class=\"keyword\">is</span> <span class=\"literal\">null</span>           </span><br><span class=\"line\">\t</span><br><span class=\"line\">可以在num上设置默认值<span class=\"number\">0</span>，确保表中num列没有<span class=\"literal\">null</span>值，</span><br><span class=\"line\">然后这样查询：</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> id <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> num=<span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> id <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> num=<span class=\"number\">10</span> <span class=\"keyword\">or</span> num=<span class=\"number\">20</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">可以这样查询：</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> id <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> num=<span class=\"number\">10</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">union</span> <span class=\"keyword\">all</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> id <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> num=<span class=\"number\">20</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">对于连续的数值，能用 <span class=\"keyword\">between</span> 就不要用 <span class=\"keyword\">in</span> 了：</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> id <span class=\"keyword\">from</span> t <span class=\"keyword\">where</span> num <span class=\"keyword\">between</span> <span class=\"number\">1</span> <span class=\"keyword\">and</span> <span class=\"number\">3</span> </span><br><span class=\"line\">\t</span><br><span class=\"line\">如果查询的两个表大小相当，那么用<span class=\"keyword\">in</span>和<span class=\"keyword\">exists</span>差别不大。</span><br><span class=\"line\"><span class=\"keyword\">in</span>：</span><br><span class=\"line\">例如：表A（小表），表B（大表）</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> A <span class=\"keyword\">where</span> cc <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> cc <span class=\"keyword\">from</span> B) 效率低，用到了A表上cc列的索引；     </span><br><span class=\"line\">\t <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> A <span class=\"keyword\">where</span> <span class=\"keyword\">exists</span>(<span class=\"keyword\">select</span> cc <span class=\"keyword\">from</span> B <span class=\"keyword\">where</span> cc=A.cc)   效率高，用到了B表上cc列的索引。   </span><br><span class=\"line\">\t</span><br><span class=\"line\">相反的</span><br><span class=\"line\"></span><br><span class=\"line\">\t <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> B <span class=\"keyword\">where</span> cc <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> cc <span class=\"keyword\">from</span> A)  效率高，用到了B表上cc列的索引；</span><br><span class=\"line\">\t <span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> B <span class=\"keyword\">where</span> <span class=\"keyword\">exists</span>(<span class=\"keyword\">select</span> cc <span class=\"keyword\">from</span> A <span class=\"keyword\">where</span> cc=B.cc)  效率低，用到了A表上cc列的索引。         </span><br></pre></td></tr></table></figure>\n<h3 id=\"更新Update语句优化\"><a href=\"#更新Update语句优化\" class=\"headerlink\" title=\"更新Update语句优化\"></a>更新Update语句优化</h3><ul>\n<li>1.如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志</li>\n</ul>\n<h3 id=\"删除Delete语句优化语句\"><a href=\"#删除Delete语句优化语句\" class=\"headerlink\" title=\"删除Delete语句优化语句\"></a>删除Delete语句优化语句</h3><ul>\n<li>1.最高效的删除重复记录方法 ( 因为使用了ROWID)例子：</li>\n</ul>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> EMP <span class=\"built_in\">E</span> <span class=\"keyword\">WHERE</span> <span class=\"built_in\">E</span>.ROWID &gt; (<span class=\"keyword\">SELECT</span> <span class=\"built_in\">MIN</span>(X.ROWID) <span class=\"keyword\">FROM</span> EMP X <span class=\"keyword\">WHERE</span> X.EMP_NO = <span class=\"built_in\">E</span>.EMP_NO);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入Insert语句优化\"><a href=\"#插入Insert语句优化\" class=\"headerlink\" title=\"插入Insert语句优化\"></a>插入Insert语句优化</h3><ul>\n<li>1.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</li>\n</ul>\n","tags":["SQL"]},{"title":"MongoDB 入门","url":"/2019/02/15/MongoDB-%E5%85%A5%E9%97%A8/","content":"<blockquote>\n<p>摘要：文档型数据库MongoDB</p>\n</blockquote>\n<p><a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\">MongoDB菜鸟教程</a></p>\n<p><a href=\"https://www.mongodb.com/\">MongoDB官网</a></p>\n<h2 id=\"1、MongoDB简介\"><a href=\"#1、MongoDB简介\" class=\"headerlink\" title=\"1、MongoDB简介\"></a>1、MongoDB简介</h2><p>（1）数据量大</p>\n<p>（2）写入操作频繁</p>\n<p>（3）价值较低</p>\n<p>对于这样的数据，我们更适合使用MongoDB来实现数据的存储</p>\n<h2 id=\"1-2、什么是MongoDB\"><a href=\"#1-2、什么是MongoDB\" class=\"headerlink\" title=\"1.2、什么是MongoDB\"></a>1.2、什么是MongoDB</h2><p>MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热<br>门的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关<br>系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以<br>存储比较复杂的数据类型。</p>\n<h2 id=\"1-3、MongoDB特点\"><a href=\"#1-3、MongoDB特点\" class=\"headerlink\" title=\"1.3、MongoDB特点\"></a>1.3、MongoDB特点</h2><p>MongoDB 最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象<br>的查<br>询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建 立索<br>引。它是一个面向集合的,模式自由的文档型数据库。<br>具体特点总结如下：</p>\n<h2 id=\"（1）面向集合存储，易于存储对象类型的数据-（2）模式自由-（3）支持动态查询-（4）支持完全索引，包含内部对象-（5）支持复制和故障恢复-（6）使用高效的二进制数据存储，包括大型对象（如视频等）-（7）自动处理碎片，以支持云计算层次的扩展性-（8）支持-Python，PHP，Ruby，Java，C，C-，Javascript，Perl-及-C-语言的驱动程序，-社区中也提供了对-Erlang-及-NET-等平台的驱动程序-（9）文件存储格式为-BSON（一种-JSON-的扩展）1-4、MongoDB体系结构\"><a href=\"#（1）面向集合存储，易于存储对象类型的数据-（2）模式自由-（3）支持动态查询-（4）支持完全索引，包含内部对象-（5）支持复制和故障恢复-（6）使用高效的二进制数据存储，包括大型对象（如视频等）-（7）自动处理碎片，以支持云计算层次的扩展性-（8）支持-Python，PHP，Ruby，Java，C，C-，Javascript，Perl-及-C-语言的驱动程序，-社区中也提供了对-Erlang-及-NET-等平台的驱动程序-（9）文件存储格式为-BSON（一种-JSON-的扩展）1-4、MongoDB体系结构\" class=\"headerlink\" title=\"（1）面向集合存储，易于存储对象类型的数据    （2）模式自由    （3）支持动态查询    （4）支持完全索引，包含内部对象    （5）支持复制和故障恢复    （6）使用高效的二进制数据存储，包括大型对象（如视频等）    （7）自动处理碎片，以支持云计算层次的扩展性    （8）支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序，    社区中也提供了对 Erlang 及.NET 等平台的驱动程序    （9）文件存储格式为 BSON（一种 JSON 的扩展）1.4、MongoDB体系结构\"></a>（1）面向集合存储，易于存储对象类型的数据<br>    （2）模式自由<br>    （3）支持动态查询<br>    （4）支持完全索引，包含内部对象<br>    （5）支持复制和故障恢复<br>    （6）使用高效的二进制数据存储，包括大型对象（如视频等）<br>    （7）自动处理碎片，以支持云计算层次的扩展性<br>    （8）支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++语言的驱动程序，<br>    社区中也提供了对 Erlang 及.NET 等平台的驱动程序<br>    （9）文件存储格式为 BSON（一种 JSON 的扩展）<br>1.4、MongoDB体系结构</h2><p>MongoDB   的逻辑结构是一种层次结构。主要由：<br>文档(document)、集合(collection)、数据库(database)这三部分组成的。逻辑结构是面 向用户的，用户使用 MongoDB 开发应用程序使用的就是逻辑结构。<br>（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。<br>（2）多个文档组成一个集合（collection），相当于关系数据库的表。<br>（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。<br>（4）一个 MongoDB 实例支持多个数据库（database）。<br>文档(document)、集合(collection)、数据库(database)的层次结构如下图:</p>\n<p><img src=\"/img/imgs/mongodb%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png\"></p>\n<p>下表是MongoDB与MySQL数据库逻辑结构概念的对比</p>\n<table>\n<thead>\n<tr>\n<th>MongoDb</th>\n<th align=\"center\">关系型数据库Mysql</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据库(databases)</td>\n<td align=\"center\">数据库(databases)</td>\n</tr>\n<tr>\n<td>集合(collections)</td>\n<td align=\"center\">表(table)</td>\n</tr>\n<tr>\n<td>文档(document)</td>\n<td align=\"center\">行(row)</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-5、数据类型\"><a href=\"#1-5、数据类型\" class=\"headerlink\" title=\"1.5、数据类型\"></a>1.5、数据类型</h2><p>基本数据类型</p>\n<p>null：用于表示空值或者不存在的字段，{“x”:null}<br>布尔型：布尔类型有两个值true和false，{“x”:true}<br>数值：shell默认使用64位浮点型数值。{“x”：3.14}或{“x”：3}。对于整型值，可以使用<br>NumberInt（4字节符号整数）或NumberLong（8字节符号整数），<br>{“x”:NumberInt(“3”)}{“x”:NumberLong(“3”)}<br>字符串：UTF-8字符串都可以表示为字符串类型的数据，{“x”：“呵呵”}<br>日期：日期被存储为自新纪元依赖经过的毫秒数，不存储时区，{“x”:new Date()}</p>\n<p>正则表达式：查询时，使用正则表达式作为限定条件，语法与JavaScript的正则表达式相 同，{“x”:&#x2F;[abc]&#x2F;}<br>数组：数据列表或数据集可以表示为数组，{“x”： [“a“，“b”,”c”]}<br>内嵌文档：文档可以嵌套其他文档，被嵌套的文档作为值来处理，{“x”:{“y”:3 }}<br>对象Id：对象id是一个12字节的字符串，是文档的唯一标识，{“x”: objectId() }<br>二进制数据：二进制数据是一个任意字节的字符串。它不能直接在shell中使用。如果要 将非utf-字符保存到数据库中，二进制数据是唯一的方式。<br>代码：查询和文档中可以包括任何JavaScript代码，{“x”:function(){&#x2F;…&#x2F;}}</p>\n<h2 id=\"2、走进MongoDB\"><a href=\"#2、走进MongoDB\" class=\"headerlink\" title=\"2、走进MongoDB\"></a>2、走进MongoDB</h2><p>2.1、MongoDB安装与启动</p>\n<p>Docker 环境下MongoDB的安装</p>\n<p><a href=\"http://www.runoob.com/docker/docker-install-mongodb.html\">Docker 安装MongoDB</a></p>\n<p>MongoDB 常用命令</p>\n<p>选择和创建数据库 ：</p>\n<pre><code>use DATABASE_NAME\n</code></pre>\n<p>查看所有数据库 ：</p>\n<pre><code>show dbs\n</code></pre>\n<p>插入和查询文档 ：</p>\n<p>插入</p>\n<pre><code>db.COLLECTION_NAME.insert(document)\n</code></pre>\n<p>查询</p>\n<pre><code>db.COLLECTION_NAME.find(query, projection)\n</code></pre>\n<blockquote>\n<blockquote>\n<p>query ：可选，使用查询操作符指定查询条件</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</p>\n</blockquote>\n</blockquote>\n<p>  返回符合条件的第一条数据 </p>\n<pre><code>db.COLLECTION_NAME.findOne()\n</code></pre>\n<p>  返回指定条数的记录 </p>\n<pre><code>db.COLLECTION_NAME.find().limit(n)\n</code></pre>\n<p>修改和删除文档<br>修改</p>\n<pre><code>db.COLLECTION_NAME.update(条件,修改后的数据)\n</code></pre>\n<p> 删除</p>\n<pre><code>db.col.remove(条件)   \ndb.col.remove(&#123;&#125;) //删除所有数据\n</code></pre>\n<p> 统计条数</p>\n<pre><code>db.col.count()\n</code></pre>\n<p>Java 操作MongoDB</p>\n<p><a href=\"http://www.runoob.com/mongodb/mongodb-java.html\">MongoDB Java</a></p>\n","tags":["MongoDB"]},{"title":"Snowflake 算法","url":"/2019/02/13/Snowflake-%E7%AE%97%E6%B3%95/","content":"<blockquote>\n<p>摘要：Snowflake算法</p>\n</blockquote>\n<h2 id=\"1、twitter雪花算法的原理\"><a href=\"#1、twitter雪花算法的原理\" class=\"headerlink\" title=\"1、twitter雪花算法的原理\"></a>1、twitter雪花算法的原理</h2><p>twitter的雪花算法，是将id按二进制比特位切割，不同的位区间，表示不同的含义，也即是不同位区间</p>\n<p>的值生成方式不同，从而生成唯一的id。</p>\n<p>如位区间可分为时间位区间、集群位区间、机器位区间、自增位区间，这样可在不同时间内、不同集群、</p>\n<p>不同机器间，生成全局唯一的id。</p>\n<h2 id=\"2、twitter雪花算法的实例\"><a href=\"#2、twitter雪花算法的实例\" class=\"headerlink\" title=\"2、twitter雪花算法的实例\"></a>2、twitter雪花算法的实例</h2><p>在此以生成64位（即Long型）为例进行介绍（其实区间位可以根据具体的业务需要自行指定）。</p>\n<p>1、位区间化分</p>\n<p>0 - 41位时间戳 - 5位数据中心标识 - 5位机器标识 - 12位序列号</p>\n<p>最高位（即第64位，从右向左数）为符号位，不使用；</p>\n<p>41位（第23位到第63位）为时间位，精确到毫秒级，可使用个数为2199023255551个，以毫秒为单位，大约69.5年；可以根据时间进行排序；</p>\n<p>5位（第18位到第22位）为集群位，可使用个数为32个；</p>\n<p>5位（第13位到第17位）为机器位，可使用个数为32个；</p>\n<p>12位（第1位到第12位）为序列号位，即是从0开始自增，可使用个数为4096个；</p>\n<p>2、确定时间位开始计算的时间点</p>\n<p>本例以2017-10-12 00:00:00开始计时，那么过去掉的时间（从1970-01-01 00:00:00开始）的毫秒数</p>\n<p>为1507737600000，取时间时需要减去这段时间。</p>\n<h2 id=\"3、示例代码\"><a href=\"#3、示例代码\" class=\"headerlink\" title=\"3、示例代码\"></a>3、示例代码</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.management.ManagementFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.NetworkInterface;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 分布式自增长ID</span></span><br><span class=\"line\"><span class=\"comment\"> * Twitter的 Snowflake　JAVA实现方案</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 核心代码为其IdWorker这个类实现，其原理结构如下，分别用一个0表示一位，用—分割开部分的作用：</span></span><br><span class=\"line\"><span class=\"comment\"> * 1||0---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---000000000000</span></span><br><span class=\"line\"><span class=\"comment\"> * 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。</span></span><br><span class=\"line\"><span class=\"comment\"> * 这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），</span></span><br><span class=\"line\"><span class=\"comment\"> * 并且效率较高，经测试，snowflake每秒能够产生26万ID左右。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 64位ID (42(毫秒)+5(机器ID)+5(业务编码)+12(重复累加))</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Search</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IdWorker</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时间起始标记点，作为基准，一般取系统的最近时间（系统时钟依赖性,一旦确定不能变动）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">twepoch</span> <span class=\"operator\">=</span> <span class=\"number\">1288834974657L</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 机器标识位数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">workerIdBits</span> <span class=\"operator\">=</span> <span class=\"number\">5L</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 数据中心标识位数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">datacenterIdBits</span> <span class=\"operator\">=</span> <span class=\"number\">5L</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 机器ID最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">maxWorkerId</span> <span class=\"operator\">=</span> -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; workerIdBits);</span><br><span class=\"line\">    <span class=\"comment\">// 数据中心ID最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">maxDatacenterId</span> <span class=\"operator\">=</span> -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class=\"line\">    <span class=\"comment\">// 毫秒内自增位</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">sequenceBits</span> <span class=\"operator\">=</span> <span class=\"number\">12L</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 机器ID偏左移12位</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">workerIdShift</span> <span class=\"operator\">=</span> sequenceBits;</span><br><span class=\"line\">    <span class=\"comment\">// 数据中心ID左移17位</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">datacenterIdShift</span> <span class=\"operator\">=</span> sequenceBits + workerIdBits;</span><br><span class=\"line\">    <span class=\"comment\">// 时间毫秒左移22位</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">timestampLeftShift</span> <span class=\"operator\">=</span> sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">sequenceMask</span> <span class=\"operator\">=</span> -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; sequenceBits);</span><br><span class=\"line\">    <span class=\"comment\">/* 上次生产id时间戳 */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"variable\">lastTimestamp</span> <span class=\"operator\">=</span> -<span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 0，并发控制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"variable\">sequence</span> <span class=\"operator\">=</span> <span class=\"number\">0L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> workerId;</span><br><span class=\"line\">    <span class=\"comment\">// 数据标识id部分</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> datacenterId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">IdWorker</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.datacenterId = getDatacenterId(maxDatacenterId);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.workerId = getMaxWorkerId(datacenterId, maxWorkerId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> workerId</span></span><br><span class=\"line\"><span class=\"comment\">     *            工作机器ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> datacenterId</span></span><br><span class=\"line\"><span class=\"comment\">     *            序列号</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">IdWorker</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> datacenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(String.format(<span class=\"string\">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(String.format(<span class=\"string\">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.workerId = workerId;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.datacenterId = datacenterId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取下一个ID</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"type\">long</span> <span class=\"title function_\">nextId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">timestamp</span> <span class=\"operator\">=</span> timeGen();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(String.format(<span class=\"string\">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前毫秒内，则+1</span></span><br><span class=\"line\">            sequence = (sequence + <span class=\"number\">1</span>) &amp; sequenceMask;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sequence == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当前毫秒内计数满了，则等待下一秒</span></span><br><span class=\"line\">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            sequence = <span class=\"number\">0L</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lastTimestamp = timestamp;</span><br><span class=\"line\">        <span class=\"comment\">// ID偏移组合生成最终的ID，并返回ID</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">nextId</span> <span class=\"operator\">=</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift)</span><br><span class=\"line\">                | (datacenterId &lt;&lt; datacenterIdShift)</span><br><span class=\"line\">                | (workerId &lt;&lt; workerIdShift) | sequence;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">tilNextMillis</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"type\">long</span> lastTimestamp)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">timestamp</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.timeGen();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class=\"line\">            timestamp = <span class=\"built_in\">this</span>.timeGen();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> timestamp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> <span class=\"title function_\">timeGen</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> System.currentTimeMillis();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取 maxWorkerId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> datacenterId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maxWorkerId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">getMaxWorkerId</span><span class=\"params\">(<span class=\"type\">long</span> datacenterId, <span class=\"type\">long</span> maxWorkerId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">mpid</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">        mpid.append(datacenterId);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> ManagementFactory.getRuntimeMXBean().getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!name.isEmpty()) &#123;</span><br><span class=\"line\">         <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          * GET jvmPid</span></span><br><span class=\"line\"><span class=\"comment\">          */</span></span><br><span class=\"line\">            mpid.append(name.split(<span class=\"string\">&quot;@&quot;</span>)[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       * MAC + PID 的 hashcode 获取16个低位</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (mpid.toString().hashCode() &amp; <span class=\"number\">0xffff</span>) % (maxWorkerId + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 数据标识 id 部分</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maxDatacenterId</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">getDatacenterId</span><span class=\"params\">(<span class=\"type\">long</span> maxDatacenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"number\">0L</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">InetAddress</span> <span class=\"variable\">ip</span> <span class=\"operator\">=</span> InetAddress.getLocalHost();</span><br><span class=\"line\">            <span class=\"type\">NetworkInterface</span> <span class=\"variable\">network</span> <span class=\"operator\">=</span> NetworkInterface.getByInetAddress(ip);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (network == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                id = <span class=\"number\">1L</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">byte</span>[] mac = network.getHardwareAddress();</span><br><span class=\"line\">                id = ((<span class=\"number\">0x000000FF</span> &amp; (<span class=\"type\">long</span>) mac[mac.length - <span class=\"number\">1</span>])</span><br><span class=\"line\">                        | (<span class=\"number\">0x0000FF00</span> &amp; (((<span class=\"type\">long</span>) mac[mac.length - <span class=\"number\">2</span>]) &lt;&lt; <span class=\"number\">8</span>))) &gt;&gt; <span class=\"number\">6</span>;</span><br><span class=\"line\">                id = id % (maxDatacenterId + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot; getDatacenterId: &quot;</span> + e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">IdWorker</span> <span class=\"variable\">idGenerator</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IdWorker</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 线程池并行执行10000次ID生成</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">long</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> idGenerator.nextId();</span><br><span class=\"line\">                    System.out.println(id);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Snowflake"]},{"title":"Spring boot与Spring cloud","url":"/2019/03/13/Spring-boot%E4%B8%8ESpring-cloud/","content":"<blockquote>\n<p>摘要：Spring boot与Spring cloud</p>\n</blockquote>\n<h2 id=\"1、什么是Spring-Boot\"><a href=\"#1、什么是Spring-Boot\" class=\"headerlink\" title=\"1、什么是Spring Boot\"></a>1、什么是Spring Boot</h2><p>Spring Boot是整合了框架的框架，它让一切依赖都变得有序简单，你不用操心A.jar是什么版本，又依赖哪些版本的jar，它默认配置了很多框架的使用方式，就像 maven整合了所有的jar包，Spring Boot整合了所有的框架，第三方库的功能你拿着就能用。<br>Spring Boot的核心思想就是约定大于配置，一切由内定的约束来自动完成。采用 Spring Boot可以大大的简化你的开发模式，节省大部分照搬照抄的成本，通过少量的代码就能创建一个独立的，它都有对应的组件支持。</p>\n<p>它是由 Pivotal团队提供的全新框架,其设计目的是用来简化新 Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置,从而使开发人员不再需要定义样板化的配置。</p>\n<p>Spring boot 是 Spring 的一套快速配置脚手架，可以基于spring boot 快速开发单个微服务，Spring Boot，看名字就知道是Spring的引导，就是用于启动Spring的，使得Spring的学习和使用变得快速无痛。不仅适合替换原有的工程结构，更适合微服务开发。</p>\n<p>以启动一个带Hibernate的Spring MVC为例。</p>\n<ol>\n<li><p>依赖太多了，而且要注意版本兼容。这个应用，要添加10-20个依赖，Spring相关的包10多个，然后是Hibernate包，Spring与Hibernate整合包，日志包，json包一堆，而且要注意版本兼容性。</p>\n</li>\n<li><p>配置太多了，要配置注解驱动，要配置数据库连接池，要配置Hibernate，要配置事务管理器，要配置Spring MVC的资源映射，要在web.xml中配置启动Spring和Spring MVC等</p>\n</li>\n</ol>\n<p>3.部署和运行麻烦。要部署到tomcat里面。不能直接用java命令运行。</p>\n<p>太多重复和大家都一样的配置了。</p>\n<p>Spring Boot的哲学就是约定大于配置。既然很多东西都是一样的，为什么还要去配置。</p>\n<ol>\n<li>通过starter和依赖管理解决依赖问题。</li>\n<li>通过自动配置，解决配置复杂问题。</li>\n<li>通过内嵌web容器，由应用启动web容器，而不是web容器启动应用，来解决部署运行问题。</li>\n</ol>\n<h2 id=\"2、什么是Spring-Cloud\"><a href=\"#2、什么是Spring-Cloud\" class=\"headerlink\" title=\"2、什么是Spring Cloud\"></a>2、什么是Spring Cloud</h2><p>Spring Cloud是一套分布式服务治理的框架,既然它是一套服务治理的框架，那么它本身不会提供具体功能性的操作，更专注于服务之间的通讯、熔断、监控等。因此就需要很多的组件来支持一套功能。<br>微服务是可以独立部署、水平扩展、独立访问(或者有独立的数据库)的服务单元， Spring Cloud就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多， Spring Cloud做为大管家就需要提供各种方案来维护整个生态。</p>\n<p>Spring Cloud基于Spring Boot，为微服务体系开发中的架构问题，提供了一整套的解决方案——服务注册与发现，服务消费，服务保护与熔断，网关，分布式调用追踪，分布式配置管理等。</p>\n<p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具；Spring boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架；spring boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置，Spring Cloud很大的一部分是基于Spring boot来实现。</p>\n<h2 id=\"3、Spring-boot与Spring-cloud-之间的关系\"><a href=\"#3、Spring-boot与Spring-cloud-之间的关系\" class=\"headerlink\" title=\"3、Spring boot与Spring cloud 之间的关系\"></a>3、Spring boot与Spring cloud 之间的关系</h2><p>你可以把spring boot的官方的包分为两类，一种是为了搭建一个服务用的，比如hibernate jpa，比如 message。另外一种含有cloud关键字的，是为了各个spring boot之前管理和使用的包。</p>\n<p>因为当把集群、CI等方法集中进来一起考虑的时候，这件事情就复杂了。</p>\n<p>多个小有服务整合成的大服务，要有一个消息总线来用于互相通知和调用，要有一个服务发现程序来管理某个小服务上线可用，同时在服务离线时也要能处理，各个小服务要尽量各自独立，还要考虑服务的依赖性，集群的负载均衡，配置文件的分离。</p>\n<p>再把CI和Docker拿进来一起考虑的话，更乱。</p>\n<p>但我认为这样完成的一个服务是更具有可插拔性，更容易维护的。而且遵循了上面的cloud方案的话，在服务的健壮性上面也很强。</p>\n<p>写到这里对于新接触的我认为可以先从单独的spring boot程序开始入门，当要添加一个新功能时，考虑拆分成另外服务。两个程序间可以通过 jmx或是 其它消息中间件或是rest通讯。最后实现了一个各自独立的功能集群。</p>\n<p>总结一句：Spring boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring boot，属于依赖的关系</p>\n<p>SpringCloud是Spring为微服务架构思想做的一个一站式实现。从某种程度是可以简单的理解为，微服务是一个概念、一个项目开发的架构思想。SpringCloud是微服务架构的一种java实现。<br>SpringCloud是基于SpringBoot的一套实现微服务的框架。它提供了微服务开发所需的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等组件。最重要的是，跟SpringBoot框架一起使用的话，会让你开发微服务架构的云服务非常方便。</p>\n<p>SpringCloud核心组件</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">消息总线  - Spring <span class=\"keyword\">cloud </span><span class=\"keyword\">Bus</span></span><br><span class=\"line\"><span class=\"keyword\"></span>配置中心分布式配置 - spring <span class=\"keyword\">cloud </span><span class=\"built_in\">config</span></span><br><span class=\"line\">服务注册发现-Netflix Eureka</span><br><span class=\"line\">负载均衡-Netflix Ribbon</span><br><span class=\"line\">断路器 - Netflix Hystrix</span><br><span class=\"line\">路由(服务网关) - Netflix Zuul</span><br><span class=\"line\">服务调用  - Netflix Feign</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","tags":["Spring boot"]},{"title":"Spring事务失效场景","url":"/2023/09/10/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/","content":"<blockquote>\n<p>摘要：Spring事务失效的场景</p>\n</blockquote>\n<h1 id=\"1-Spring-框架配置问题\"><a href=\"#1-Spring-框架配置问题\" class=\"headerlink\" title=\"1.Spring 框架配置问题\"></a>1.Spring 框架配置问题</h1><h2 id=\"1-service类没有被Spring管理\"><a href=\"#1-service类没有被Spring管理\" class=\"headerlink\" title=\"1. service类没有被Spring管理\"></a>1. service类没有被Spring管理</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@Service （注释了@Service）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">xxxServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">xxxService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addxxx</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面例子中，Spring事务没有生效，因为<strong>Spring事务是由AOP机制实现</strong>的，也就是从Spring IOC 容器中获取bean 时，Spring 会为目标类创建代理，来支持事务的。但是@Service被注释后，service类都不是被Spring 管理的，更不会创建代理来支持事务。</p>\n<h2 id=\"2、没有在Spring配置中启用事务管理器\"><a href=\"#2、没有在Spring配置中启用事务管理器\" class=\"headerlink\" title=\"2、没有在Spring配置中启用事务管理器\"></a>2、没有在Spring配置中启用事务管理器</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TransactionConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 没有配置事务管理器</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>没有配置事务管理器，Spring无法创建事务代理对象，导致事务不生效。</strong></p>\n<p>解决方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableTransactionManagement</span> </span><br><span class=\"line\"><span class=\"comment\">// 开启Spring Boot 的事务管理功能 等同于xml配置方式的 &lt;tx:annotation-driven /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TransactionConfig</span> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//不管是JPA还是JDBC等都实现自接口 PlatformTransactionManager 如果添加的是 spring-boot-starter-jdbc 依赖，框架会默认注入 DataSourceTransactionManager。如果添加的是 spring-boot-starter-data-jpa，框架会默认注入 JpaTransactionManager。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DataSource dataSource;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;transactionManager&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> PlatformTransactionManager <span class=\"title function_\">transactionManager</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataSourceTransactionManager</span>(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果是<strong>SpringBoot</strong>项目，<strong>默认会自动配置事务管理器并开启事务支持</strong>的。</p>\n<h1 id=\"2-Spring-AOP-代理问题\"><a href=\"#2-Spring-AOP-代理问题\" class=\"headerlink\" title=\"2. Spring AOP 代理问题\"></a>2. Spring AOP 代理问题</h1><h2 id=\"1-事务方法被final、static关键字修饰\"><a href=\"#1-事务方法被final、static关键字修饰\" class=\"headerlink\" title=\"1.事务方法被final、static关键字修饰\"></a>1.事务方法被final、static关键字修饰</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 事务不生效</span></span><br><span class=\"line\"><span class=\"comment\">  * 方法用final 或static 修饰</span></span><br><span class=\"line\"><span class=\"comment\">  * 提示：Methods annotated with &#x27;<span class=\"doctag\">@Transactional</span>&#x27; must be overridable</span></span><br><span class=\"line\"><span class=\"comment\">  * 虽然有提示事物注解不能有final修饰，但是可以编译通过</span></span><br><span class=\"line\"><span class=\"comment\">  * 事物不会回滚，新增成功，更新失败</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>事务不生效的原因：如果一个方法被<strong>声明为final或者static</strong>，<strong>则该方法不能被子类重写，也就是说无法在该方法上进行动态代理，这会导致Spring无法生成事务代理对象来管理事务。</strong></p>\n<h2 id=\"2-同一个类中，方法内部调用\"><a href=\"#2-同一个类中，方法内部调用\" class=\"headerlink\" title=\"2.同一个类中，方法内部调用\"></a>2.同一个类中，方法内部调用</h2><figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 事务不生效</span></span><br><span class=\"line\"><span class=\"comment\">  * 方法内部调用</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"variable\">@Override</span></span><br><span class=\"line\"> <span class=\"variable\">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class=\"line\"> public void <span class=\"built_in\">doSomething</span>() &#123;</span><br><span class=\"line\">     <span class=\"selector-tag\">insert</span>();</span><br><span class=\"line\">     <span class=\"comment\">// 事物修改</span></span><br><span class=\"line\">     <span class=\"selector-tag\">updateTransactional</span>();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>事务不生效的原因: <strong>事务是通过Spring AOP代理来实现的</strong>，<strong>而在同一个类中，一个方法调用另一个方法时，调用方法直接调用目标方法的代码，而不是通过代理类进行调用。</strong>调用目标方法不是通过代理类进行的，因此事务不生效。</p>\n<p><strong>解决方案</strong>：<strong>可以新建多一个类，让这两个方法分开，分别在不同的类中</strong>,<strong>也可以在该 Service 类中注入自己，或者通过AopContext.currentProxy()获取代理对象。</strong></p>\n<h2 id=\"3-方法的访问权限不是public\"><a href=\"#3-方法的访问权限不是public\" class=\"headerlink\" title=\"3.方法的访问权限不是public\"></a>3.方法的访问权限不是public</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 事务不生效</span></span><br><span class=\"line\"><span class=\"comment\">  * 方法的访问权限不是public</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>事务不生效的原因：<strong>Spring事务是由AOP机制实现的，AOP机制的本质是动态代理，而代理的事务方法不是public的话，AbstractFallbackTransactionAttributeSource.computeTransactionAttribute()就会返回null，也就是这时事务属性不存在了。</strong></p>\n<h1 id=\"3-数据库不支持\"><a href=\"#3-数据库不支持\" class=\"headerlink\" title=\"3.数据库不支持\"></a>3.数据库不支持</h1><h2 id=\"数据库的存储引擎不支持事务\"><a href=\"#数据库的存储引擎不支持事务\" class=\"headerlink\" title=\"数据库的存储引擎不支持事务\"></a>数据库的存储引擎不支持事务</h2><p>Spring事务的底层，还是依赖于数据库本身的事务支持。<strong>在MySQL中，MyISAM存储引擎是不支持事务的，InnoDB引擎才支持事务。</strong>因此开发阶段设计表的时候，<strong>确认你的选择的存储引擎是支持事务的</strong>。</p>\n<h1 id=\"4-Transactional配置问题\"><a href=\"#4-Transactional配置问题\" class=\"headerlink\" title=\"4.@Transactional配置问题\"></a>4.@Transactional配置问题</h1><p><img src=\"/img/@Transactional%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3.jpg\"></p>\n<p><strong>readOnly&#x3D;true</strong></p>\n<p><strong>事务超时时间设置过短</strong> <strong>timeout</strong></p>\n<p><strong>使用了错误的事务传播机制</strong>  <strong>propagation &#x3D;Propagation.NOT_SUPPORTED传播特性不支持事务。</strong></p>\n<p><strong>rollbackFor属性配置错误 rollbackFor属性指定的异常必须是Throwable或者其子类。</strong></p>\n<h1 id=\"5-开发使用不当\"><a href=\"#5-开发使用不当\" class=\"headerlink\" title=\"5.开发使用不当\"></a>5.开发使用不当</h1><h2 id=\"1-事务注解被覆盖导致事务失效\"><a href=\"#1-事务注解被覆盖导致事务失效\" class=\"headerlink\" title=\"1.事务注解被覆盖导致事务失效\"></a>1.事务注解被覆盖导致事务失效</h2><h2 id=\"2-嵌套事务\"><a href=\"#2-嵌套事务\" class=\"headerlink\" title=\"2.嵌套事务\"></a>2.嵌套事务</h2><h2 id=\"3-事务多线程调用\"><a href=\"#3-事务多线程调用\" class=\"headerlink\" title=\"3.事务多线程调用\"></a>3.事务多线程调用</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 事务不生效</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">  mapper.save();</span><br><span class=\"line\">  <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">   mapper.insert(); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>事务失效原因：这是因为<strong>Spring事务是基于线程绑定</strong>的，每个线程都有自己的事务上下文，而<strong>多线程环境下可能会存在多个线程共享同一个事务上下文的情况</strong>，导致事务失效。<strong>Spring事务管理器通过使用线程本地变量（ThreadLocal）来实现线程安全</strong>。</p>\n<blockquote>\n<p>在Spring事务管理器中，通过TransactionSynchronizationManager类来管理事务上下文。TransactionSynchronizationManager内部维护了一个ThreadLocal对象，用来存储当前线程的事务上下文。在事务开始时，TransactionSynchronizationManager会将事务上下文绑定到当前线程的ThreadLocal对象中，当事务结束时，TransactionSynchronizationManager会将事务上下文从ThreadLocal对象中移除。</p>\n</blockquote>\n<h2 id=\"4-异常被捕获并处理了，没有重新抛出\"><a href=\"#4-异常被捕获并处理了，没有重新抛出\" class=\"headerlink\" title=\"4.异常被捕获并处理了，没有重新抛出\"></a>4.异常被捕获并处理了，没有重新抛出</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 事务不生效</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"meta\">@Transactional(rollbackFor = Exception.class)</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">       mapper.insert();</span><br><span class=\"line\">     &#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">     \tlog.error(<span class=\"string\">&quot;message:&#123;&#125;&quot;</span>,e.getMessage());</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>事务不生效的原因: <strong>事务中的异常已经被业务代码捕获并处理，而没有被正确地传播回事务管理器，事务将无法回滚</strong>。我们可以从Spring源码(TransactionAspectSupport这个类)中找到答案.在invokeWithinTransaction方法中，当Spring catch到Throwable异常的时候，就会调用completeTransactionAfterThrowing()方法进行事务回滚的逻辑。</p>\n<p><strong>解决方案</strong>：</p>\n<p><strong>1.在Spring事务方法中，当我们使用了try-catch，如果catch住异常，记录完异常日志什么的，一定要重新把异常抛出来.</strong></p>\n<p><strong>2.手动回滚事物 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</strong></p>\n<h2 id=\"5-手动抛了别的异常\"><a href=\"#5-手动抛了别的异常\" class=\"headerlink\" title=\"5.手动抛了别的异常\"></a>5.手动抛了别的异常</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 事务不生效</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"meta\">@Transactional</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">     <span class=\"comment\">//</span></span><br><span class=\"line\">   <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Exception</span>();</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>事务不生效的原因：上面的代码例子中，手动抛了Exception异常，但是是不会回滚的，因为<strong>Spring默认只处理RuntimeException和Error，对于普通的Exception不会回滚，除非，用rollbackFor属性指定配置。</strong></p>\n<p>解决方案：**添加属性配置@Transactional(rollbackFor &#x3D; Exception.class)**。</p>\n<p><img src=\"/img/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF.jpg\"></p>\n","tags":["事务失效"]},{"title":"Token Auth","url":"/2019/03/02/Token-Auth/","content":"<blockquote>\n<p>摘要：Token</p>\n</blockquote>\n<h2 id=\"1、Token简介\"><a href=\"#1、Token简介\" class=\"headerlink\" title=\"1、Token简介\"></a>1、Token简介</h2><p>Token 是一种权限认证机制，在服务端不需要存储用户的登陆记录。</p>\n<h2 id=\"2、Token流程\"><a href=\"#2、Token流程\" class=\"headerlink\" title=\"2、Token流程\"></a>2、Token流程</h2><p>（1）客户端使用name password 请求登陆</p>\n<p>（2）服务端接收请求，去验证name password</p>\n<p>（3）验证成功会，服务端会签发一个Token 在把这个Token发送给服务端</p>\n<p>（4）客户端收到Token 并把它存储起来，如放入header、Cookie</p>\n<p>（5）客户端每次向服务端请求资源时需要携带服务端签发的Token</p>\n<p>（6）服务端收到请求，然后去验证客户端请求里携带的Token，验证成功，返回客户端请求的资源</p>\n<h2 id=\"2、Token-Auth-的优点\"><a href=\"#2、Token-Auth-的优点\" class=\"headerlink\" title=\"2、Token Auth 的优点\"></a>2、Token Auth 的优点</h2><p>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</p>\n<p>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</p>\n<p>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</p>\n<p>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</p>\n<p>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</p>\n<p>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。</p>\n<p>性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.</p>\n<p>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</p>\n<p>基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</p>\n","tags":["Token"]},{"title":"assert","url":"/2019/05/20/assert/","content":"<blockquote>\n<p>摘要： 本文主要介绍单点登录系统Junit的assert。</p>\n</blockquote>\n<hr>\n<p>断言是编写测试用例的核心实现方式，即期望值是多少，测试的结果是多少，以此来判断测试是否通过。</p>\n<ol>\n<li><p>断言核心方法 Assert</p>\n<p>assertArrayEquals(expecteds, actuals)\t查看两个数组是否相等。</p>\n<p>assertEquals(expected, actual)\t查看两个对象是否相等。类似于字符串比较使用的equals()方法</p>\n<p>assertNotEquals(first, second)\t查看两个对象是否不相等。</p>\n<p>assertNull(object)\t查看对象是否为空。</p>\n<p>assertNotNull(object)\t查看对象是否不为空。</p>\n<p>assertSame(expected, actual)\t查看两个对象的引用是否相等。类似于使用“&#x3D;&#x3D;”比较两个对象</p>\n<p>assertNotSame(unexpected, actual)\t查看两个对象的引用是否不相等。类似于使用“!&#x3D;”比较两个对象</p>\n<p>assertTrue(condition)\t查看运行结果是否为true。</p>\n<p>assertFalse(condition)\t查看运行结果是否为false。</p>\n<p>assertThat(actual, matcher)\t查看实际值是否满足指定的条件</p>\n<p>fail()\t让测试失败</p>\n</li>\n</ol>\n<p>2、Junit基本注解介绍</p>\n<p>   &#x2F;&#x2F;在所有测试方法前执行一次，一般在其中写上整体初始化代码 </p>\n<p>   @BeforeClass</p>\n<p>   &#x2F;&#x2F;在所有测试方法后执行一次，一般在其中写上销毁和释放资源的代码 </p>\n<p>   @AfterClass</p>\n<p>   &#x2F;&#x2F;在每个测试方法前执行，一般用来初始化方法（比如我们在测试别的方法时，类中与其他测试方法共享的值已经被改变，为了保证测试结果的有效性，我们会在@Before注解的方法中重置数据） </p>\n<p>   @Before</p>\n<p>   &#x2F;&#x2F;在每个测试方法后执行，在方法执行完成后要做的事情 </p>\n<p>   @After</p>\n<p>   &#x2F;&#x2F; 测试方法执行超过1000毫秒后算超时，测试将失败 </p>\n<p>   @Test(timeout &#x3D; 1000)</p>\n<p>   &#x2F;&#x2F; 测试方法期望得到的异常类，如果方法执行没有抛出指定的异常，则测试失败 </p>\n<p>   @Test(expected &#x3D; Exception.class)</p>\n<p>   &#x2F;&#x2F; 执行测试时将忽略掉此方法，如果用于修饰类，则忽略整个类 </p>\n<p>   @Ignore(“not ready yet”) </p>\n<p>   @Test</p>\n<p>   @RunWith </p>\n<p>   在JUnit中有很多个Runner，他们负责调用你的测试代码，每一个Runner都有各自的特殊功能，你要根据需要选择不同的Runner来运行你的测试代码。<br>    如果我们只是简单的做普通Java测试，不涉及Spring Web项目，你可以省略@RunWith注解，这样系统会自动使用默认Runner来运行你的代码。</p>\n<p> 3.项目中中如何使用Junit</p>\n<p>  创建测试类，在测试类中添加注解</p>\n<p>  @RunWith(SpringRunner.class)</p>\n<p>  @SpringBootTest(classes&#x3D;{xxApplication.class})&#x2F;&#x2F;项目启动类</p>\n","tags":["assert"]},{"title":"es 单机版集群搭建","url":"/2019/04/20/es-%E5%8D%95%E6%9C%BA%E7%89%88%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/","content":"<blockquote>\n<p>摘要： 本文主要介绍es 单机版集群搭建。</p>\n</blockquote>\n<p>es 单机版集群搭建</p>\n<p>  主要配置文件<br>   –elasticsearch.yml es配置文件<br>   –jvm.options jvm相关的配置 内存大小等等<br>   –log4j2.properties 日志系统定义<br>   es 集群 主从<br>   head 插件-web管理器<br>   logstash –数据库与Elasticsearch同步索引</p>\n<p>集群搭建</p>\n<p>   1 安装jdk</p>\n<p>   2 安装es 将es拷贝3份</p>\n<p>   3 集群搭建demo、本机测试只需将192.168.35.124换成自己电脑ip即可</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">master</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">cluster.name:</span> <span class=\"string\">notice-application</span>  <span class=\"comment\"># 集群名称集群节点cluster.name需一致</span></span><br><span class=\"line\">  <span class=\"attr\">node.name:</span> <span class=\"string\">master</span>   <span class=\"comment\">#节点名称</span></span><br><span class=\"line\">  <span class=\"attr\">node.master:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">network.host:</span> <span class=\"number\">192.168</span><span class=\"number\">.35</span><span class=\"number\">.124</span>    <span class=\"comment\"># 当前节点的IP地址</span></span><br><span class=\"line\">  <span class=\"comment\"># network.bind_host: 192.168.11.21</span></span><br><span class=\"line\">  <span class=\"attr\">http.port:</span> <span class=\"number\">9200</span>  <span class=\"comment\"># 对外提供服务的端口，9300为集群服务</span></span><br><span class=\"line\">  <span class=\"attr\">transport.tcp.port:</span> <span class=\"number\">9300</span></span><br><span class=\"line\">  <span class=\"attr\">discovery.zen.ping.unicast.hosts:</span> [<span class=\"string\">&quot;192.168.35.124:9300&quot;</span>,<span class=\"string\">&quot;192.168.35.124:9310&quot;</span>,<span class=\"string\">&quot;192.168.35.124:9320&quot;</span>]</span><br><span class=\"line\">  <span class=\"comment\"># 集群个节点IP地址</span></span><br><span class=\"line\">  <span class=\"attr\">discovery.zen.minimum_master_nodes:</span> <span class=\"number\">2</span>    <span class=\"comment\"># 为了避免脑裂，集群节点数最少为 半数+1</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"string\">slave1</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"attr\">cluster.name:</span> <span class=\"string\">notice-application</span></span><br><span class=\"line\">  <span class=\"attr\">node.name:</span> <span class=\"string\">slave1</span></span><br><span class=\"line\">  <span class=\"comment\"># network.publish_host: 192.168.11.21</span></span><br><span class=\"line\">  <span class=\"comment\"># network.bind_host: 192.168.11.21</span></span><br><span class=\"line\">  <span class=\"attr\">network.host:</span> <span class=\"number\">192.168</span><span class=\"number\">.35</span><span class=\"number\">.124</span></span><br><span class=\"line\">  <span class=\"attr\">http.port:</span> <span class=\"number\">9210</span></span><br><span class=\"line\">  <span class=\"attr\">transport.tcp.port:</span> <span class=\"number\">9310</span></span><br><span class=\"line\">  <span class=\"attr\">discovery.zen.ping.unicast.hosts:</span> [<span class=\"string\">&quot;192.168.35.124:9300&quot;</span>,<span class=\"string\">&quot;192.168.35.124:9310&quot;</span>,<span class=\"string\">&quot;192.168.35.124:9320&quot;</span>]</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"string\">slave2</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">cluster.name:</span> <span class=\"string\">notice-application</span></span><br><span class=\"line\">  <span class=\"attr\">node.name:</span> <span class=\"string\">slave2</span></span><br><span class=\"line\">  <span class=\"comment\"># network.publish_host: 192.168.11.21</span></span><br><span class=\"line\">  <span class=\"comment\"># network.bind_host: 192.168.11.21</span></span><br><span class=\"line\">  <span class=\"attr\">network.host:</span> <span class=\"number\">192.168</span><span class=\"number\">.35</span><span class=\"number\">.124</span></span><br><span class=\"line\">  <span class=\"attr\">http.port:</span> <span class=\"number\">9220</span></span><br><span class=\"line\">  <span class=\"attr\">transport.tcp.port:</span> <span class=\"number\">9320</span></span><br><span class=\"line\">  <span class=\"attr\">discovery.zen.ping.unicast.hosts:</span> [<span class=\"string\">&quot;192.168.35.124:9300&quot;</span>,<span class=\"string\">&quot;192.168.35.124:9310&quot;</span>,<span class=\"string\">&quot;192.168.35.124:9320&quot;</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  启动master、slave1、slave2 3个节点</p>\n<p>  浏览器输入 <a href=\"http://192.168.35.124:9200/_cat/nodes?v\">http://192.168.35.124:9200/_cat/nodes?v</a> 查看集群 显示如下：则集群搭建成功</p>\n<p>  <img src=\"/img/elasticsearch.png\"></p>\n","tags":["elasticsearch"]},{"title":"jpa 常用注解","url":"/2019/09/22/jpa-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","content":"<pre><code>\nimport org.springframework.data.annotation.CreatedDate;\nimport org.springframework.data.annotation.LastModifiedDate;\nimport org.springframework.data.jpa.domain.support.AuditingEntityListener;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.EntityListeners;\nimport java.io.Serializable;\nimport java.time.LocalDateTime;\n//Spring Data JPA 的时间注解\n/**\n * @author Search\n * @version 1.0\n * @date 2019/9/2 10:25\n */\n@Entity\n@EntityListeners(AuditingEntityListener.class)\npublic class Base implements Serializable &#123;\n    \n    //选择 Spring Data JPA 框架开发时，常用在实体和字段上的注解有@Entity、@Id、@Column等。在表设计规范中，通常建议保留的有两个字段，一个是更新时间，一个是创建时间。Spring Data JPA 提供了相应的时间注解，只需要两步配置，就可以帮助开发者快速实现这方面的功能。\n\n//在实体类上加上注解 @EntityListeners(AuditingEntityListener.class)，在相应的字段上添加对应的时间注解 @LastModifiedDate 和 @CreatedDate\n\n//日期类型可以用 Date 也可以是 Long\n\n    private static final long serialVersionUID = 7297611707550474985L;\n\n    @Id\n    private String id;//ID\n\n    /**\n     * 更新时间 日期类型可以是 Long\n     */\n    @LastModifiedDate\n    @Column(name = &quot;update_time&quot;,nullable = false)\n    private LocalDateTime updateTime;\n\n    /**\n     * 创建时间 日期类型可以是 Long\n     * name 对应数据库中字段名\n     * updatable = false 更新数据时不更新该字段\n     * nullable = false 数据库中不允许为null\n     */\n    @CreatedDate\n    @Column(name = &quot;create_time&quot;,updatable = false, nullable = false)\n    private LocalDateTime createTime;\n\n    \n&#125;\n2//启动类添加  @EnableJpaAuditing\n\n在Application启动类中添加注解 @EnableJpaAuditing\n@EnableJpaAuditing\n@SpringBootApplication\npublic class Application &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Application.class, args);\n    &#125;\n    \n&#125;\n\n\nspring 注解验证 常用标签\n\n@Null  被注释的元素必须为null\n@NotNull  被注释的元素不能为null\n@NotEmpty  被注释的字符串必须非空\n@AssertTrue  被注释的元素必须为true\n@AssertFalse  被注释的元素必须为false\n@Length 被注释的字符串的大小必须在指定的范围内 \n@Digits(integer,fraction)  被注释的元素必须是一个数字，其值必须在可接受的范围内\n@Min(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n@Max(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n@DecimalMin(value)  被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n@DecimalMax(value)  被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n@Size(max,min)  被注释的元素的大小必须在指定的范围内。\n@Past  被注释的元素必须是一个过去的日期\n@Future  被注释的元素必须是一个将来的日期\n@Pattern(value) 被注释的元素必须符合指定的正则表达式。\n@Email 被注释的元素必须是电子邮件地址\n@Range  被注释的元素必须在合适的范围内\n@URL(protocol=,host,port) 检查是否是一个有效的URL,如果提供了protocol,host等，则该URL还需满足提供的条件\n\n\n\n\nSpringBoot的Web组件内部集成了hibernate-validator，所以我们这里并不需要额外的为验证再导入其他的包，接下来我们先来看看SpringBoot为我们提供了哪些验证。\n\n内置验证\nSpringBoot因为采用了hibernate-validator，所以我们直接使用hibernate-validator就可以进行数据校验\n\n\n\n````````\n</code></pre>\n"},{"title":"redis主从复制原理、断点续传、无磁盘化复制、过期key处理","url":"/2019/11/13/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E3%80%81%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E3%80%81%E6%97%A0%E7%A3%81%E7%9B%98%E5%8C%96%E5%A4%8D%E5%88%B6%E3%80%81%E8%BF%87%E6%9C%9Fkey%E5%A4%84%E7%90%86/","content":"<p><img src=\"/img/imgs/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86.png\"> </p>\n<h1 id=\"1、主从架构的核心原理\"><a href=\"#1、主从架构的核心原理\" class=\"headerlink\" title=\"1、主从架构的核心原理\"></a>1、主从架构的核心原理</h1><ul>\n<li>当启动一个slave node的时候，它会发送一个PSYNC命令给master node</li>\n</ul>\n<p>如果这是slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据; 否则如果是slave node第一次连接master node，那么会触发一次full resynchronization</p>\n<p>开始full resynchronization的时候，master会启动一个后台线程，开始生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕之后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中。然后master会将内存中缓存的写命令发送给slave，slave也会同步这些数据。</p>\n<p>slave node如果跟master node有网络故障，断开了连接，会自动重连。master如果发现有多个slave node都来重新连接，仅仅会启动一个rdb save操作，用一份数据服务所有slave node。</p>\n<h1 id=\"2、主从复制的断点续传\"><a href=\"#2、主从复制的断点续传\" class=\"headerlink\" title=\"2、主从复制的断点续传\"></a>2、主从复制的断点续传</h1><ul>\n<li>从redis 2.8开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份</li>\n</ul>\n<p>master node会在内存中常见一个backlog，master和slave都会保存一个replica offset还有一个master id，offset就是保存在backlog中的。如果master和slave网络连接断掉了，slave会让master从上次的replica offset开始继续复制</p>\n<p>但是如果没有找到对应的offset，那么就会执行一次resynchronization</p>\n<h1 id=\"3、无磁盘化复制\"><a href=\"#3、无磁盘化复制\" class=\"headerlink\" title=\"3、无磁盘化复制\"></a>3、无磁盘化复制</h1><ul>\n<li>master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘了</li>\n</ul>\n<p>repl-diskless-sync<br>repl-diskless-sync-delay，等待一定时长再开始复制，因为要等更多slave重新连接过来</p>\n<h1 id=\"4、过期key处理\"><a href=\"#4、过期key处理\" class=\"headerlink\" title=\"4、过期key处理\"></a>4、过期key处理</h1><p>slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。</p>\n","tags":["Redis"]},{"title":"redis如何通过读写分离来承载读请求QPS超过10万+？","url":"/2019/11/13/redis%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9D%A5%E6%89%BF%E8%BD%BD%E8%AF%BB%E8%AF%B7%E6%B1%82QPS%E8%B6%85%E8%BF%8710%E4%B8%87-%EF%BC%9F/","content":"<h1 id=\"1、redis高并发跟整个系统的高并发之间的关系\"><a href=\"#1、redis高并发跟整个系统的高并发之间的关系\" class=\"headerlink\" title=\"1、redis高并发跟整个系统的高并发之间的关系\"></a>1、redis高并发跟整个系统的高并发之间的关系</h1><ul>\n<li>redis，你要搞高并发的话，不可避免，要把底层的缓存搞得很好</li>\n</ul>\n<p>mysql，高并发，做到了，那么也是通过一系列复杂的分库分表，订单系统，事务要求的，QPS到几万，比较高了</p>\n<p>要做真正的超高并发，QPS上十万，甚至是百万，一秒钟百万的请求量</p>\n<p>光是redis是不够的，但是redis是整个大型的缓存架构中，支撑高并发的架构里面，非常重要的一个环节</p>\n<p>首先，你的底层的缓存中间件，缓存系统，必须能够支撑的起我们说的那种高并发，其次，再经过良好的整体的缓存架构的设计（多级缓存架构、热点缓存），支撑真正的上十万，甚至上百万的高并发</p>\n<h1 id=\"2、redis不能支撑高并发的瓶颈在哪里？\"><a href=\"#2、redis不能支撑高并发的瓶颈在哪里？\" class=\"headerlink\" title=\"2、redis不能支撑高并发的瓶颈在哪里？\"></a>2、redis不能支撑高并发的瓶颈在哪里？</h1><p>单机</p>\n<p><img src=\"/img/imgs/redis%E5%8D%95%E6%9C%BA%E7%9A%84%E7%93%B6%E9%A2%88.png\"> </p>\n<h1 id=\"3、如果redis要支撑超过10万-的并发，那应该怎么做？\"><a href=\"#3、如果redis要支撑超过10万-的并发，那应该怎么做？\" class=\"headerlink\" title=\"3、如果redis要支撑超过10万+的并发，那应该怎么做？\"></a>3、如果redis要支撑超过10万+的并发，那应该怎么做？</h1><p>单机的redis几乎不太可能说QPS超过10万+，除非一些特殊情况，比如你的机器性能特别好，配置特别高，物理机，维护做的特别好，而且你的整体的操作不是太复杂</p>\n<p>单机在几万</p>\n<p>读写分离，一般来说，对缓存，一般都是用来支撑读高并发的，写的请求是比较少的，可能写请求也就一秒钟几千，一两千</p>\n<p>大量的请求都是读，一秒钟二十万次读</p>\n<p>读写分离</p>\n<p>主从架构 -&gt; 读写分离 -&gt; 支撑10万+读QPS的架构</p>\n<p><img src=\"/img/imgs/redis%E4%B8%BB%E4%BB%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%94%AF%E6%92%9110%E4%B8%87+%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91.png\"> </p>\n<p>redis replication</p>\n<p>redis主从架构 -&gt; 读写分离架构 -&gt; 可支持水平扩展的读高并发架构</p>\n<h1 id=\"4、redis-replication的核心机制\"><a href=\"#4、redis-replication的核心机制\" class=\"headerlink\" title=\"4、redis replication的核心机制\"></a>4、redis replication的核心机制</h1><p>（1）redis采用异步方式复制数据到slave节点，不过redis 2.8开始，slave node会周期性地确认自己每次复制的数据量</p>\n<p>（2）一个master node是可以配置多个slave node的</p>\n<p>（3）slave node也可以连接其他的slave node</p>\n<p>（4）slave node做复制的时候，是不会block master node的正常工作的</p>\n<p>（5）slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务; 但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了</p>\n<p>（6）slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量</p>\n<p>![](&#x2F;img&#x2F;imgs&#x2F;redis replica最最基本的原理.png)</p>\n<p>slave，高可用性，有很大的关系</p>\n<h1 id=\"5、master持久化对于主从架构的安全保障的意义\"><a href=\"#5、master持久化对于主从架构的安全保障的意义\" class=\"headerlink\" title=\"5、master持久化对于主从架构的安全保障的意义\"></a>5、master持久化对于主从架构的安全保障的意义</h1><ul>\n<li>如果采用了主从架构，那么建议必须开启master node的持久化！</li>\n</ul>\n<p>不建议用slave node作为master node的数据热备，因为那样的话，如果你关掉master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，salve node数据也丢了</p>\n<p>master -&gt; RDB和AOF都关闭了 -&gt; 全部在内存中</p>\n<p>master宕机，重启，是没有本地数据可以恢复的，然后就会直接认为自己IDE数据是空的</p>\n<p>master就会将空的数据集同步到slave上去，所有slave的数据全部清空</p>\n<p>100%的数据丢失</p>\n<p>master节点，必须要使用持久化机制</p>\n<p>第二个，master的各种备份方案，要不要做，万一说本地的所有文件丢失了; 从备份中挑选一份rdb去恢复master; 这样才能确保master启动的时候，是有数据的</p>\n","tags":["Redis"]},{"title":"【Javaweb】购物车实现","url":"/2018/12/15/%E3%80%90Javaweb%E3%80%91%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%AE%9E%E7%8E%B0/","content":"<h2 id=\"1-购物车实现方式\"><a href=\"#1-购物车实现方式\" class=\"headerlink\" title=\"1.购物车实现方式\"></a>1.购物车实现方式</h2><h2 id=\"1-用cookie实现购物车；2-用session实现购物车；3-用cookie和数据库-购物车信息持久化-实现购物车；\"><a href=\"#1-用cookie实现购物车；2-用session实现购物车；3-用cookie和数据库-购物车信息持久化-实现购物车；\" class=\"headerlink\" title=\"1.用cookie实现购物车；2.用session实现购物车；3.用cookie和数据库(购物车信息持久化)实现购物车；\n    \"></a>1.用cookie实现购物车；<br><br>2.用session实现购物车；<br><br>3.用cookie和数据库(购物车信息持久化)实现购物车；\n    </h2><p>1.单纯有cookie实现购物车，这样的购物车不是很理想，设想一下，如果客户端的浏览器把cookie给禁用了…</p>\n<p>2.session中保存购物车的信息，这个只是在一个会话中可用，如果用户没有登录，或者说登录了以后，添加购物车，在关闭浏览器…</p>\n<h2 id=\"2-分析\"><a href=\"#2-分析\" class=\"headerlink\" title=\"2.分析\"></a>2.分析</h2><p>1、添加购物车不需要用户登录。购物车的数据应该放到cookie中。</p>\n<p>2、当向购物车添加同一款商品时，购物车中商品的数量增加。</p>\n<p>3、购物车中可以删除商品</p>\n<p>4、购物车中可以修改商品数量。商品的总价需要重新计算。</p>\n<p>5、点击“结算”按钮要求用户登录。</p>\n<h2 id=\"3-实现\"><a href=\"#3-实现\" class=\"headerlink\" title=\"3.实现\"></a>3.实现</h2><p>A.用户登录前的数据流：用户在没有登录系统的时候，对喜欢的商品进行添加购物车，那么这个时候，我们可以把购物车信息保存到cookie中，这里会涉及到cookie的添加，修改操作；也即如果之前在cookie中不存对应的cookie，则就对cookie进行添加操作。</p>\n<p>如果在cookie中存在对应的cookie，那么，这时候，就要对cookie进行修改操作了(这里涉及到用户对同一个商品进行多次添加购物车的情况)。</p>\n<p>B.用户登录后的数据流：用户在登录后，系统首先做的第一件事就是去获取对应的cookies，如果存在相关的购物车cookies，那么就对该购物车信息进行相应用户User的持久化操作，要么添加，要么修改。（添加操作:该用户所对应的购物车如果没有相应的信息进行添加操作；修改操作：类似的，</p>\n<p>如果存在对应用户的购物车信息，就进行修改操作）。用户登录后，也可以进行购物车的添加操作，不过，这里不是添加到cookie中，而是直接持久化到数据库中。注：用户登录后的数据都是和数据库打交道。</p>\n","tags":["cart"]},{"title":"【Java】开发过程中的内存溢出及解决办法","url":"/2018/12/15/%E3%80%90Java%E3%80%91%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","content":"<blockquote>\n<p>摘要： 本文主要是对开发过程中存在的内存溢出问题及解决办法。</p>\n</blockquote>\n<h2 id=\"1-引起内存溢出的原因有很多种，常见如下：\"><a href=\"#1-引起内存溢出的原因有很多种，常见如下：\" class=\"headerlink\" title=\"1.引起内存溢出的原因有很多种，常见如下：\"></a>1.引起内存溢出的原因有很多种，常见如下：</h2><ol>\n<li>内存中加载的数据量过于庞大，如一次从库取出多数据;</li>\n<li>集合类中有对对象的引用，使完后未清空，使得JVM 不能回收;</li>\n<li>代码中存在死循环或循环产生过多重复的对象实体; </li>\n<li>使用的 第三方软件中的BUG;</li>\n<li>启动参数内存值设定的过小;</li>\n</ol>\n<h2 id=\"2-内存溢出的解决方案：\"><a href=\"#2-内存溢出的解决方案：\" class=\"headerlink\" title=\"2.内存溢出的解决方案： \"></a>2.内存溢出的解决方案： </h2><p>第一步，修改 JVM 启动参数，直接增加内存。（-Xms,Xmx参数不要忘记加）</p>\n<p>第二步，检查错误日志，查看‘outOfMemory’错误前是否有其它异常或错误。</p>\n<p>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</p>\n<ol>\n<li>检查对数据库询中，是否有一次获得全部的数据。一般来说如果一次取十万条记录到内存就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出现问题，上线后，数据库中数据增多，一次查询可能引起内存溢出。因此对于数据库查询尽可能采用分页的方式查询。</li>\n<li>检查代码中是否有死循环或递归调用。</li>\n<li>检查是否有大循环重复产生新对象实体。</li>\n<li>检查List、Map 等集合对象是否有使用完后未清除的问题。List、Map 等集合对象会始终存有对对象的引用，使得这些对象不能被GC 回收。</li>\n</ol>\n<p>第四步，使用内存查看工具动态查看内存使用情况。</p>\n<pre><code>\n\n\n\n</code></pre>\n","tags":["Java"]},{"title":"【Java】线程","url":"/2018/12/15/%E3%80%90Java%E3%80%91%E7%BA%BF%E7%A8%8B/","content":"<blockquote>\n<p>摘要：主要介绍线程</p>\n</blockquote>\n<h2 id=\"1-进程和线程的区别\"><a href=\"#1-进程和线程的区别\" class=\"headerlink\" title=\"1.进程和线程的区别\"></a>1.进程和线程的区别</h2><h2 id=\"进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU-调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；-1-1进程和线程的关系：\"><a href=\"#进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU-调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；-1-1进程和线程的关系：\" class=\"headerlink\" title=\"进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU 调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；&gt;1.1进程和线程的关系：\"></a>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资<br>源分配和调度的一个独立单位。<br><br>线程是进程的一个实体，是CPU 调度和分派的基本单位，他是比进程更小的能独立运<br>行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如<br>程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；<br><br>&gt;1.1进程和线程的关系：</h2><p>①一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</p>\n<p>②资源分配给进程，同一进程的所有线程共享该进程的所有资源。</p>\n<p>③线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p>\n<p>④处理机分给线程，即真正在处理机上运行的是线程。</p>\n<p>⑤线程是指进程内的一个执行单元，也是进程内的可调度实体。</p>\n<blockquote>\n<p>1.2线程与进程的区别：</p>\n</blockquote>\n<hr>\n<p>①调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。</p>\n<p>②并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。</p>\n<h2 id=\"③拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进-程的资源。④系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明-显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不-会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和-局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进-程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。-线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有-独立的内存单元，而多个线程共享内存，从而极大的提高了程序运行效率。-线程在执行过程中，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出-口。但是线程不能够独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制。-从逻辑角度看，多线程的意义子啊与一个应用程序中，有多个执行部分可以同时执行。但操-作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这-就是进程和线程的重要区别。2-出现死锁的条件\"><a href=\"#③拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进-程的资源。④系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明-显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不-会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和-局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进-程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。-线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有-独立的内存单元，而多个线程共享内存，从而极大的提高了程序运行效率。-线程在执行过程中，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出-口。但是线程不能够独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制。-从逻辑角度看，多线程的意义子啊与一个应用程序中，有多个执行部分可以同时执行。但操-作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这-就是进程和线程的重要区别。2-出现死锁的条件\" class=\"headerlink\" title=\"③拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进    程的资源。④系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明    显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不    会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和    局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进    程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。    线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有    独立的内存单元，而多个线程共享内存，从而极大的提高了程序运行效率。    线程在执行过程中，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出    口。但是线程不能够独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制。    从逻辑角度看，多线程的意义子啊与一个应用程序中，有多个执行部分可以同时执行。但操    作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这    就是进程和线程的重要区别。2.出现死锁的条件\"></a>③拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进<br>    程的资源。<br><br>④系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明<br>    显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不<br>    会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和<br>    局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进<br>    程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。<br>    线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有<br>    独立的内存单元，而多个线程共享内存，从而极大的提高了程序运行效率。<br>    线程在执行过程中，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出<br>    口。但是线程不能够独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制。<br>    从逻辑角度看，多线程的意义子啊与一个应用程序中，有多个执行部分可以同时执行。但操<br>    作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这<br>    就是进程和线程的重要区别。<br><br>2.出现死锁的条件</h2><p>出现死锁有4 个必要条件：</p>\n<p>①互斥：存在互斥使用的资源，也就是临界资源；</p>\n<p>②占有等待：拥有资源的进程都在等待另外的资源；</p>\n<p>③非剥夺：进行所占有的资源是不可剥夺使用的资源；</p>\n<h2 id=\"④循环等待：都在相互等待资源。3-多线程中stop-为什么不合适\"><a href=\"#④循环等待：都在相互等待资源。3-多线程中stop-为什么不合适\" class=\"headerlink\" title=\"④循环等待：都在相互等待资源。3.多线程中stop 为什么不合适\"></a>④循环等待：都在相互等待资源。<br><br>3.多线程中stop 为什么不合适</h2><h2 id=\"多线程之间一般是有联系的，若用stop-停止了线程，容易强行打断线程之间的联系，-容易产生错误。4-Sleep-和wait-的区别\"><a href=\"#多线程之间一般是有联系的，若用stop-停止了线程，容易强行打断线程之间的联系，-容易产生错误。4-Sleep-和wait-的区别\" class=\"headerlink\" title=\"多线程之间一般是有联系的，若用stop 停止了线程，容易强行打断线程之间的联系，    容易产生错误。4.Sleep 和wait 的区别\"></a>多线程之间一般是有联系的，若用stop 停止了线程，容易强行打断线程之间的联系，<br>    容易产生错误。<br>4.Sleep 和wait 的区别</h2><p>①sleep 是Thread 类中的，wait 是Object 中的；</p>\n<p>②sleep 会在指定时间之后自动唤醒，wait 需要其他线程调用notify 或者notifyAll 唤醒；</p>\n<p>③sleep 还有个最大的特点就是谁调用，谁睡觉，即使在a 类中调用b 的sleep 方法，实际上还是a 去睡觉。</p>\n<p>④wait 只能使用在同步控制方法或者同步控制块中使用，sleep 在任何地方都能被使用；</p>\n<h2 id=\"⑤持有锁的线程执行sleep，不释放锁，持有锁的线程执行到wait（）时锁释放。5-线程的五个状态和特点\"><a href=\"#⑤持有锁的线程执行sleep，不释放锁，持有锁的线程执行到wait（）时锁释放。5-线程的五个状态和特点\" class=\"headerlink\" title=\"⑤持有锁的线程执行sleep，不释放锁，持有锁的线程执行到wait（）时锁释放。5.线程的五个状态和特点\"></a>⑤持有锁的线程执行sleep，不释放锁，持有锁的线程执行到wait（）时锁释放。<br>5.线程的五个状态和特点</h2><p>①新建状态(New)：新创建了一个线程对象。</p>\n<p>②就绪状态(Runnable)：线程对象创建后,其他线程调用了该对象的start()方法.该状态的线程位于可运行线程池中,变得可运行,等待获取CPU 的使用权.</p>\n<p>③运行状态(Running)：就绪状态的线程获取了CPU,执行程序代码.</p>\n<p>④阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU 使用权,暂时停止运行.<br>    直到线程进入就绪状态,才有机会转到运行状态.阻塞的情况分三种：A）等待阻塞：运行的线程执<br>    行wait()方法,JVM 会把该线程放入等待池中。B）同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用,则JVM 会把该线程放入锁池中。 C）其他阻塞：<br>    运行的线程执行sleep()或join()方法,或者发出了I&#x2F;O 请求时,JVM 会把该线程置为阻塞状态.当sleep()状态超时 join()等待线程终止或者超时 或者I&#x2F;O 处理完毕时,线程重新转入就绪状态.</p>\n<p>⑤死亡状态(Dead)：线程执行完了或者因异常退出了run()方法,该线程结束生命周<br>期.</p>\n<h2 id=\"6-线程的生命周期\"><a href=\"#6-线程的生命周期\" class=\"headerlink\" title=\"6.线程的生命周期\"></a>6.线程的生命周期</h2><p><img src=\"/img/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg\"></p>\n<h2 id=\"7-什么情况下使用Thread-什么情况下使用Runnable\"><a href=\"#7-什么情况下使用Thread-什么情况下使用Runnable\" class=\"headerlink\" title=\"7.什么情况下使用Thread 什么情况下使用Runnable\"></a>7.什么情况下使用Thread 什么情况下使用Runnable</h2><p>继承Thread 类：如果一个类有了父类，便无法再继承。实现Runnale：更灵活，没<br>有单继承的局限。\t</p>\n","tags":["thread"]},{"title":"【Netty】NIO 编程","url":"/2018/12/24/%E3%80%90Netty%E3%80%91NIO-%E7%BC%96%E7%A8%8B/","content":"<blockquote>\n<p>摘要：主要介绍NIO 编程</p>\n</blockquote>\n<p>网络编程的基本模型是client&#x2F;server 模型（两个进程之间的相互通信） 服务端提供位置信息&#x2F;绑定ip地址和监听端口）客户端通过连接操作向服务器监听的地址发送连接请求，通过三次握手建立通信，如连接成功 则通过网络套接字&#x2F;socket&#x2F;通信。</p>\n<h2 id=\"基于传统同步阻塞模型开发中，serverSocket-负责绑定ip-地址，启动监听端口，socket-负责发起连接操作。连接成功之后，双方通过输入输出流进行同步阻塞式通信。1-BIO通信模型图\"><a href=\"#基于传统同步阻塞模型开发中，serverSocket-负责绑定ip-地址，启动监听端口，socket-负责发起连接操作。连接成功之后，双方通过输入输出流进行同步阻塞式通信。1-BIO通信模型图\" class=\"headerlink\" title=\"基于传统同步阻塞模型开发中，serverSocket 负责绑定ip 地址，启动监听端口，socket 负责发起连接操作。连接成功之后，双方通过输入输出流进行同步阻塞式通信。1.BIO通信模型图\"></a>基于传统同步阻塞模型开发中，serverSocket 负责绑定ip 地址，启动监听端口，socket 负责发起连接操作。连接成功之后，双方通过输入输出流进行同步阻塞式通信。<br><br>1.BIO通信模型图</h2><p><img src=\"/img/imgs/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9Eio%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.jpg\">  </p>\n<p>采用BIO 通信模型的服务端，通常由一个独立的Acceptor 线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回应答给客户段，线程销毁。</p>\n<p>该模型缺乏弹性伸缩能力，当客户端并发并访问量增加，服务端的线程个数和客户端访问呈1：1 相关，由于线程是Java虚拟机的宝贵资源，当线程数膨胀后，系统的性能将急剧下降，随着并发访问增大，系统会发生堆栈溢出 创建新线程失败，最终导致进程宕机或者僵死，不能对外提供服务</p>\n<blockquote>\n<p>1、BIO 的主要问题在于每当有一个新的客户端请求接入时，服务端必须创建一个新的线程处理新接入的客户端链路，一个线程只能处理一个客户端连接，在高性能服务器应用领域，需要面对上万个客户端的并发连接，无法满足高性能高并发接入的场景</p>\n</blockquote>\n<blockquote>\n<p>2、为了改进一线程一连接模型，通过线程池或者消息队列实现，一个或者多个线程处理n个客户端的模型，由于它的底层通信机制依然使用同步阻塞IO，所以被称为伪异步，</p>\n</blockquote>\n<h2 id=\"2-伪异步IO编程\"><a href=\"#2-伪异步IO编程\" class=\"headerlink\" title=\"2.伪异步IO编程\"></a>2.伪异步IO编程</h2><p>后端通过一个线程池来处理多个客户端的请求接入，客户端个数M 线程池最大线程数N，通过线程池灵活调配线程资源，设置线程的最大值，防止并发接入导致线程耗尽，</p>\n<p>伪异步IO模型图<br><img src=\"/img/imgs/asyn-io.png\"><br>当有新的客户端接入的时候，将客户端的Socket封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理,JDK的线程池维护一个消息队列和N个活跃线程对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。 </p>\n<p>伪异步IO通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。但是由于它底层的通信依然采用同步阻塞模型，因此无法从根本上解决问题。<br>伪异步IO弊端分析</p>\n<h2 id=\"3-NIO编程\"><a href=\"#3-NIO编程\" class=\"headerlink\" title=\"3.NIO编程\"></a>3.NIO编程</h2><p>NIO提供SocketChannel和 ServerSocketChannel不同的套接字通道实现;<br>通常 低负载 低并发的应用选择同步阻塞IO降低复杂度  高并发 高负载选择NIO 的非阻塞式模式</p>\n<h2 id=\"NIO类库简介1缓冲区buffer2通道channel3多复用selector4-NIO服务端序列图\"><a href=\"#NIO类库简介1缓冲区buffer2通道channel3多复用selector4-NIO服务端序列图\" class=\"headerlink\" title=\"NIO类库简介1缓冲区buffer2通道channel3多复用selector4.NIO服务端序列图\"></a>NIO类库简介<br><br>1缓冲区buffer<br><br>2通道channel<br><br>3多复用selector<br><br>4.NIO服务端序列图</h2><p><img src=\"/img/imgs/NIO%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BA%8F%E5%88%97%E5%9B%BE.png\">  </p>\n<p>NIO客户端序列图<br><img src=\"/img/imgs/NIO%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%8F%E5%88%97%E5%9B%BE.png\"> </p>\n<p>NIO的优点</p>\n<ol>\n<li><p>不需要使用read()或者write()操作就可以处理文件内容了</p>\n</li>\n<li><p>修改文件后，修改自动flush到文件</p>\n</li>\n<li><p>nio方式能很快处理大文件和处理效率很快</p>\n</li>\n</ol>\n<p>4种IO的对比</p>\n<p>不同IO模型对比</p>\n<p>总结<br>    IO的编程和使用差异，对比各自的缺点，给出使用建议对netty进行分析和总结</p>\n","tags":["Netty"]},{"title":"【Netty】为什么选择Netty","url":"/2018/12/24/%E3%80%90Netty%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Netty/","content":"<blockquote>\n<p>摘要：主要介绍选择Netty 的理由</p>\n</blockquote>\n<h2 id=\"1-不选择Java-原生NIO-编程的原因\"><a href=\"#1-不选择Java-原生NIO-编程的原因\" class=\"headerlink\" title=\"1.不选择Java 原生NIO 编程的原因\"></a>1.不选择Java 原生NIO 编程的原因</h2><p>NIO 的类库和API 繁杂，使用麻烦，你需要熟练掌握Selector，ServerSocketChannel，SocketChannel，ByteBuffer 等。</p>\n<p>需要其他技能做铺垫，如熟悉Java 多线程编程。这是应为NIO 编程涉及Reactor 模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO 程序。</p>\n<p>可靠性能力不齐，工作量和难度大。比如客户端面临断连重连，网络闪断，半包读写，失败缓存，网络拥塞，异常码流等问题。NIO 开发的特点是功能开发相对简单，但可靠性不强，工作量大。</p>\n<p>JDK NIO 的bug，如epoll bug 会导致Selector 空轮询，最终导致CPU 100%。</p>\n<h2 id=\"2-为什么选择Netty\"><a href=\"#2-为什么选择Netty\" class=\"headerlink\" title=\"2.为什么选择Netty\"></a>2.为什么选择Netty</h2><p>netty 是业界最流行的NIO 框架之一，它的健壮性 功能 性能 可定制性和可扩展性在同类框架中都是首屈一指的<br>    netty优点：</p>\n<p>api简单 开发门槛低。</p>\n<p>功能强大 预置了多种编解码功能，支持多种主流协议。</p>\n<p>定制能力强，可以通过channelHandler对通信框架进行灵活扩展。</p>\n<p>性能高，通过与其他业界主流的NIO 框架对比 ，netty 的综合性能最优。</p>\n<p>成熟 稳定，netty修复了已经发现的所有jdk NIO bug ，业务人员不需要在为NIO 的bug 而烦恼。</p>\n<p>社区活跃，版本迭代周期短，发现的bug 可以被及时修复，更多的新功能也会加入。</p>\n<p>经历了大规模的商业应用的检验，质量得到验证，netty 在互联网 大数据 网络游戏 企业应用 电信软件等众多行业中得到成功商用。</p>\n","tags":["Netty"]},{"title":"【分布式】单点登录系统","url":"/2018/12/15/%E3%80%90SSO%E3%80%91%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/","content":"<blockquote>\n<p>摘要： 本文主要介绍单点登录系统。</p>\n</blockquote>\n<h2 id=\"1-什么是单点登录系统\"><a href=\"#1-什么是单点登录系统\" class=\"headerlink\" title=\"1.什么是单点登录系统\"></a>1.什么是单点登录系统</h2><p>SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。<br> SSO单点登录系统就是使用redis模拟Session（Key-Value），实现Session的统一管理。</p>\n<h2 id=\"2-创建单点登录系统\"><a href=\"#2-创建单点登录系统\" class=\"headerlink\" title=\"2.创建单点登录系统\"></a>2.创建单点登录系统</h2><h2 id=\"使用的技术：\"><a href=\"#使用的技术：\" class=\"headerlink\" title=\"使用的技术：\"></a>使用的技术：</h2><p>1、Mybatis</p>\n<p>2、Spring</p>\n<p>3、Springmvc</p>\n<p>4、Jedis</p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><h2 id=\"SSO表现层-定义了三个处理器，分别用于注册、登录、外部调用，查看用户登录状态：-登录拦截器分析当用户提交订单时此时必须要求用户登录，可以使用拦截器来实现。拦截器的处理流程：\"><a href=\"#SSO表现层-定义了三个处理器，分别用于注册、登录、外部调用，查看用户登录状态：-登录拦截器分析当用户提交订单时此时必须要求用户登录，可以使用拦截器来实现。拦截器的处理流程：\" class=\"headerlink\" title=\"SSO表现层        定义了三个处理器，分别用于注册、登录、外部调用，查看用户登录状态：\t## 登录拦截器分析当用户提交订单时此时必须要求用户登录，可以使用拦截器来实现。拦截器的处理流程：\"></a>SSO表现层<br>        定义了三个处理器，分别用于注册、登录、外部调用，查看用户登录状态：\t<br><br>## 登录拦截器<br>分析<br>当用户提交订单时此时必须要求用户登录，可以使用拦截器来实现。<br>拦截器的处理流程：</h2><p>1、拦截请求url</p>\n<p>2、从cookie中取token</p>\n<p>3、如果没有toke跳转到登录页面。</p>\n<p>4、取到token，需要调用sso系统的服务查询用户信息。</p>\n<p>5、如果用户session已经过期，跳转到登录页面</p>\n<p>6、如果没有过期，放行。\n     </p>\n","tags":["SSO"]},{"title":"【分布式】分布式环境中三种Session管理方法的使用场景及优缺点","url":"/2018/10/14/%E3%80%90Session%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%B8%89%E7%A7%8DSession%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/","content":"<p>在分布式环境，管理Session通常使用下面三种方式：</p>\n<h2 id=\"一、Session-Replication-方式管理-即session复制\"><a href=\"#一、Session-Replication-方式管理-即session复制\" class=\"headerlink\" title=\"一、Session Replication 方式管理 (即session复制)\"></a>一、Session Replication 方式管理 (即session复制)</h2><p>简介：将一台机器上的Session数据广播复制到集群中其余机器上</p>\n<p>使用场景：机器较少，网络流量较小</p>\n<p>优点：实现简单、配置较少、当网络中有机器Down掉时不影响用户访问</p>\n<p>缺点：广播式复制到其余机器有一定廷时，带来一定网络开销</p>\n<h2 id=\"二、Session-Sticky-方式管理\"><a href=\"#二、Session-Sticky-方式管理\" class=\"headerlink\" title=\"二、Session Sticky 方式管理\"></a>二、Session Sticky 方式管理</h2><p>简介：即粘性Session、当用户访问集群中某台机器后，强制指定后续所有请求均落到此机器上</p>\n<p>使用场景：机器数适中、对稳定性要求不是非常苛刻</p>\n<p>优点：实现简单、配置方便、没有额外网络开销</p>\n<p>缺点：网络中有机器Down掉时、用户Session会丢失、容易造成单点故障</p>\n<h2 id=\"三、缓存集中式管理\"><a href=\"#三、缓存集中式管理\" class=\"headerlink\" title=\"三、缓存集中式管理\"></a>三、缓存集中式管理</h2><p>简介：将Session存入分布式缓存集群中的某台机器上，当用户访问不同节点时先从缓存中拿Session信息</p>\n<p>使用场景：集群中机器数多、网络环境复杂</p>\n<p>优点：可靠性好</p>\n<p>缺点：实现复杂、稳定性依赖于缓存的稳定性、Session信息放入缓存时要有合理的策略写入</p>\n","tags":["Session"]},{"title":"【短信验证】短信验证码流程","url":"/2018/12/20/%E3%80%90%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E3%80%91%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0/","content":"<blockquote>\n<p>摘要： 本文主要介绍短信验证码。</p>\n</blockquote>\n<h2 id=\"1-为什么需要验证码\"><a href=\"#1-为什么需要验证码\" class=\"headerlink\" title=\"1.为什么需要验证码\"></a>1.为什么需要验证码</h2><p>短信验证码用于保护网站。试想一下，如果有人使用作弊设备，在您的网站上多次注册，登录，发布和评论不仅会严重影响网站的运行，导致网站缓慢打开，还会导致大量垃圾内容，这将不可避免地导致网站体验。如果平台用户的注册不再需要输入手机验证码，商务平台每天将受到不同的攻击，运营和维护成本将大幅增加，并且使用用户移动互联网将大大减少。垃圾邮件的影响和规模将无法预测。对于平台，服务器资源是有限的。如果有人恶意登录，或使用软件发送垃圾邮件，则会导致服务器崩溃并最终拖动平台。因此，在网站的操作中，需要添加短信验证码功能。</p>\n<p>其次，短信验证码是由商家向用户发出的用于验证身份的证书。短信验证码平台通过手机短信发送验证码，这是验证用户真实身份的最常用，最安全的方式。通过手机号码验证注册会员，您可以确认手机号码属于我。提高网站用户注册的质量，并可以更有效地管理网站的注册用户。通过手机验证码，商家可以更方便地获取用户信息，并与他们进行交互，随时与他们保持联系和沟通。第三，用户的手机号码也可以绑定，派生出更多的短信验证码应用。例如手机密码恢复，登录保护，交易确认，手机发送指令，手机账号和用户注册账号等可以同步登录，同步通讯录，同步更多手机相关应用。短信验证码的使用有效提高了用户账号的安全性，是电子商务和行业网站不可或缺的一部分。高质量的短信验证码对于改善用户体验具有不可替代的作用。</p>\n<h2 id=\"2-短信验证流程\"><a href=\"#2-短信验证流程\" class=\"headerlink\" title=\"2.短信验证流程\"></a>2.短信验证流程</h2><p>1、构造手机验证码，如生成一个6位的随机数字串；</p>\n<p>2、正则验证手机号，使用接口向短信平台发送手机号和验证码，然后短信平台再把验证码发送到指定的手机号上；</p>\n<p>3、将手机号、验证码、操作时间存入Session中，作为后面验证使用；</p>\n<p>4、接收用户填写的验证码、手机号及其他注册数据，提交；</p>\n<p>5、对比提交的验证码与Session中的验证码是否一致，同时判断提交动作是否在有效期内；</p>\n<p>6、验证码正确且在有效期内，请求通过，处理相应的业务</p>\n","tags":["短信验证"]},{"title":"全局唯一邀请码生生成","url":"/2019/06/29/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E9%82%80%E8%AF%B7%E7%A0%81%E7%94%9F%E7%94%9F%E6%88%90/","content":"<blockquote>\n<p>摘要： 本文主要介绍全局唯一邀请码生生成。</p>\n</blockquote>\n<h2 id=\"1-为什么需要邀请码\"><a href=\"#1-为什么需要邀请码\" class=\"headerlink\" title=\"1.为什么需要邀请码\"></a>1.为什么需要邀请码</h2><p>无论什么APP需要做推广功能，而推广功能多多少少都离不开邀请码。被邀请用户下载APP登录时输入邀请码，邀请码所有者将获得一定的好处，比如积分奖励、现金奖励或者免费试用（VIP）等特权。一套优秀的邀请码生成机制不仅确保全局唯一性，还需要考虑到性能等问题</p>\n<h2 id=\"2-邀请码的特性\"><a href=\"#2-邀请码的特性\" class=\"headerlink\" title=\"2.邀请码的特性\"></a>2.邀请码的特性</h2><p>唯一性：确保每个用户的邀请码都是独一无二的，这样系统才能判定谁为邀请者，甚至可以根据邀请码进行反向推导。<br>随机性：不能让用户从邀请码上轻易的看出生成的规则。<br>高效性：生成邀请码的算法不能过于复杂，或耗费过度系统资源。<br>简洁性：用户可以方便的输入，记录，辨别是否输入错误等</p>\n<h2 id=\"3-随机生成邀请码\"><a href=\"#3-随机生成邀请码\" class=\"headerlink\" title=\"3.随机生成邀请码\"></a>3.随机生成邀请码</h2><p>无论是纯数字还是数字加大写字母形式，使用随机算法生成一个邀请码然后判断此随机码是否已经被使用，如果被使用则重新生成。这可能是最初步的思路，但此种方法弊端甚多。</p>\n<p>以6为随机数为例说明。6位随机数取0-9共10个数字，生成邀请码的范围为000000-999999，总数为10的6次方，也就是100万。试想一下，如果有50万的用户，那么采用随机数的生成，每次生成的重复概率将在50%以上，而且会越来越重复率越高，多么可怕的性能损耗。</p>\n<p>当然，在用户量比较少的情况下此种方法不是完全不可行。可以通过数据库或redis预先生成一批邀请码，当注册新用户或用户使用邀请码的时候将邀请码分配给对应的用户。此种补漏的方法虽然解决了一部分性能的问题，但从根本上还是需要消耗数据库或redis资源，时间维度和空间维度都有一定的损耗。</p>\n<h2 id=\"base编码方式实现\"><a href=\"#base编码方式实现\" class=\"headerlink\" title=\"base编码方式实现\"></a>base编码方式实现</h2><p>一般来说生成一个用户的邀请码需要一个唯一的输入参数，这里就用用户的ID（长整型数）来作为输入参数，输出结果为6为数字+大写字母。同时，通过邀请码可以反推出用户的ID。</p>\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 邀请码生成器，基本原理：&lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 1）入参用户ID：1 &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 2）使用自定义进制转换之后为：V &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 3）转换未字符串，并在后面添加&#x27;A&#x27;：VA &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 4）在VA后面再随机补足4位，得到：VAHKHE &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 5）反向转换时以&#x27;A&#x27;为分界线，&#x27;A&#x27;后面的不再解析 &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ShareCodeUtil</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 自定义进制(0,1没有加入,容易与o,l混淆)，数组顺序可进行调整增加反推难度，A用来补位因此此数组不包含A，共31个字符。可扩展小写.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">char</span>[] BASE = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[] &#123; <span class=\"string\">&#x27;H&#x27;</span>, <span class=\"string\">&#x27;V&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;8&#x27;</span>, <span class=\"string\">&#x27;S&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span>, <span class=\"string\">&#x27;Z&#x27;</span>, <span class=\"string\">&#x27;X&#x27;</span>, <span class=\"string\">&#x27;9&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;7&#x27;</span>, <span class=\"string\">&#x27;P&#x27;</span>,</span><br><span class=\"line\">\t\t\t<span class=\"string\">&#x27;5&#x27;</span>, <span class=\"string\">&#x27;I&#x27;</span>, <span class=\"string\">&#x27;K&#x27;</span>, <span class=\"string\">&#x27;3&#x27;</span>, <span class=\"string\">&#x27;M&#x27;</span>, <span class=\"string\">&#x27;J&#x27;</span>, <span class=\"string\">&#x27;U&#x27;</span>, <span class=\"string\">&#x27;F&#x27;</span>, <span class=\"string\">&#x27;R&#x27;</span>, <span class=\"string\">&#x27;4&#x27;</span>, <span class=\"string\">&#x27;W&#x27;</span>, <span class=\"string\">&#x27;Y&#x27;</span>, <span class=\"string\">&#x27;L&#x27;</span>, <span class=\"string\">&#x27;T&#x27;</span>, <span class=\"string\">&#x27;N&#x27;</span>, <span class=\"string\">&#x27;6&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;G&#x27;</span>, <span class=\"string\">&#x27;Q&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * A补位字符，不能与自定义重复</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">char</span> SUFFIX_CHAR = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 进制长度</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> BIN_LEN = BASE.length;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 生成邀请码最小长度</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"type\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> CODE_LEN = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * ID转换为邀请码</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * @param id</span></span><br><span class=\"line\"><span class=\"comment\">\t * @return</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> <span class=\"type\">String</span> <span class=\"title\">idToCode</span><span class=\"params\">(Long id)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span>[] buf = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[BIN_LEN];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> charPos = BIN_LEN;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 当id除以数组长度结果大于0，则进行取模操作，并以取模的值作为数组的坐标获得对应的字符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (id / BIN_LEN &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> index = (<span class=\"type\">int</span>) (id % BIN_LEN);</span><br><span class=\"line\">\t\t\tbuf[--charPos] = BASE[index];</span><br><span class=\"line\">\t\t\tid /= BIN_LEN;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tbuf[--charPos] = BASE[(<span class=\"type\">int</span>) (id % BIN_LEN)];</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将字符数组转化为字符串</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(buf, charPos, BIN_LEN - charPos);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 长度不足指定长度则随机补全</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> len = result.<span class=\"built_in\">length</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (len &lt; CODE_LEN) &#123;</span><br><span class=\"line\">\t\t\tStringBuilder sb = <span class=\"keyword\">new</span> <span class=\"built_in\">StringBuilder</span>();</span><br><span class=\"line\">\t\t\tsb.<span class=\"built_in\">append</span>(SUFFIX_CHAR);</span><br><span class=\"line\">\t\t\tRandom random = <span class=\"keyword\">new</span> <span class=\"built_in\">Random</span>();</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 去除SUFFIX_CHAR本身占位之后需要补齐的位数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; CODE_LEN - len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t\tsb.<span class=\"built_in\">append</span>(BASE[random.<span class=\"built_in\">nextInt</span>(BIN_LEN)]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tresult += sb.<span class=\"built_in\">toString</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 邀请码解析出ID&lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t * 基本操作思路恰好与idToCode反向操作。</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * @param code</span></span><br><span class=\"line\"><span class=\"comment\">\t * @return</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> Long <span class=\"title\">codeToId</span><span class=\"params\">(<span class=\"type\">String</span> code)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span>[] charArray = code.<span class=\"built_in\">toCharArray</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> result = <span class=\"number\">0L</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; BIN_LEN; j++) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (charArray[i] == BASE[j]) &#123;</span><br><span class=\"line\">\t\t\t\t\tindex = j;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (charArray[i] == SUFFIX_CHAR) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t\tresult = result * BIN_LEN + index;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tresult = index;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> code = <span class=\"built_in\">idToCode</span>(<span class=\"number\">1L</span>);</span><br><span class=\"line\">\t\tSystem.out.<span class=\"built_in\">println</span>(code);</span><br><span class=\"line\">\t\tSystem.out.<span class=\"built_in\">println</span>(<span class=\"built_in\">codeToId</span>(code));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","tags":["ShareCodeUtil"]},{"title":"前后端API交互如何保证安全性","url":"/2019/01/06/%E5%89%8D%E5%90%8E%E7%AB%AFAPI%E4%BA%A4%E4%BA%92%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E6%80%A7/","content":"<blockquote>\n<p>摘要： 本文主要介绍前后端API交互如何保证安全性</p>\n</blockquote>\n<h2 id=\"1-为什么要保证安全性\"><a href=\"#1-为什么要保证安全性\" class=\"headerlink\" title=\"1.为什么要保证安全性\"></a>1.为什么要保证安全性</h2><p>前后端分离的开发方式，以接口为标准进行推动，定义好接口后，各自开发自己的功能，最后进行联调整合。无论是原生app的开发还是webapp的开发<br>还是pc软件，只要是前后端分离模式的软件，就避免不了调用后端接口进行数据交互。</p>\n<p>不安全的接口，通过网络，只要进行抓包就可以清楚地知道请求的数据，如果是敏感信息，稍有不慎就会被不法分子盗用。</p>\n<h2 id=\"2-如何保证API调用数据时的安全性\"><a href=\"#2-如何保证API调用数据时的安全性\" class=\"headerlink\" title=\"2.如何保证API调用数据时的安全性\"></a>2.如何保证API调用数据时的安全性</h2><p>1、通信时使用https协议</p>\n<p>2、请求签名，防止参数被修改</p>\n<p>3、身份确认机制，每次请求都要验证身份是否合法</p>\n<p>4、对所有的请求和响应都进行加解密操作</p>\n<p>等等</p>\n","tags":["安全"]},{"title":"如何保障消息的可靠性传输","url":"/2019/07/14/%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93/","content":"<blockquote>\n<p>摘要： 本文主要介绍如何保证消息的可靠性传输（如何处理消息丢失的问题）？</p>\n</blockquote>\n<p>1.丢数据，mq一般分为两种，要么是mq自己弄丢了，要么是我们消费的时候弄丢了。咱们从rabbitmq来分析一下吧</p>\n<h1 id=\"1）生产者弄丢了数据\"><a href=\"#1）生产者弄丢了数据\" class=\"headerlink\" title=\"1）生产者弄丢了数据\"></a>1）生产者弄丢了数据</h1><p>生产者将数据发送到rabbitmq的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。</p>\n<p>此时可以选择用rabbitmq提供的事务功能，就是生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息；如果收到了消息，那么可以提交事务（channel.txCommit）。但是问题是，rabbitmq事务机制一搞，基本上吞吐量会下来，因为太耗性能。</p>\n<p>所以一般来说，如果你要确保说写rabbitmq的消息别丢，可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p>\n<p>事务机制和cnofirm机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息rabbitmq接收了之后会异步回调你一个接口通知你这个消息接收到了。</p>\n<p>所以一般在生产者这块避免数据丢失，都是用confirm机制的。</p>\n<h1 id=\"2）rabbitmq弄丢了数据\"><a href=\"#2）rabbitmq弄丢了数据\" class=\"headerlink\" title=\"2）rabbitmq弄丢了数据\"></a>2）rabbitmq弄丢了数据</h1><p>就是rabbitmq自己弄丢了数据，这个你必须开启rabbitmq的持久化，就是消息写入之后会持久化到磁盘，哪怕是rabbitmq自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。</p>\n<p>设置持久化有两个步骤，</p>\n<p>第一个是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据；</p>\n<p>第二个是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘上去。</p>\n<p>必须要同时设置这两个持久化才行，rabbitmq哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。</p>\n<p>而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，rabbitmq挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。</p>\n<p>哪怕是你给rabbitmq开启了持久化机制，也有一种可能，就是这个消息写到了rabbitmq中，但是还没来得及持久化到磁盘上，结果不巧，此时rabbitmq挂了，就会导致内存里的一点点数据会丢失。</p>\n<h1 id=\"3）消费端弄丢了数据\"><a href=\"#3）消费端弄丢了数据\" class=\"headerlink\" title=\"3）消费端弄丢了数据\"></a>3）消费端弄丢了数据</h1><p>rabbitmq如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，rabbitmq认为你都消费了，这数据就丢了。</p>\n<p>这个时候得用rabbitmq提供的ack机制，简单来说，就是你关闭rabbitmq自动ack，可以通过一个api来调用就行，然后每次你自己代码里确保处理完的时候，再程序里ack一把。这样的话，如果你还没处理完，不就没有ack？那rabbitmq就认为你还没处理完，这个时候rabbitmq会把这个消费分配给别的consumer去处理，消息是不会丢的。</p>\n<h1 id=\"4）小结\"><a href=\"#4）小结\" class=\"headerlink\" title=\"4）小结\"></a>4）小结</h1><p>消息队列是如何确保消息的可靠<br>性，不会丢失的。这个过程可以分为分三个阶段，每个阶段都需要正确的编写代码并且设置<br>正确的配置项，才能配合消息队列的可靠性机制，确保消息不会丢失。</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">在生产阶段，需要捕获消息发送的错误，并重发消息。</span><br><span class=\"line\">在存储阶段，可以通过配置刷盘和复制相关的参数，让消息写入到多个副本的磁盘上，</span><br><span class=\"line\">来确保消息不会因为某个 <span class=\"keyword\">Broker </span>宕机或者磁盘损坏而丢失。</span><br><span class=\"line\">在消费阶段，你需要在处理完全部消费业务逻辑之后，再发送消费确认。</span><br></pre></td></tr></table></figure>\n\n<p>在理解了这几个阶段的原理后，如果再出现丢消息的情况，可以通过在代码中加一些<br>日志的方式，很快定位到是哪个阶段出了问题，然后再进一步深入分析，快速找到问题原<br>因。</p>\n","tags":["消息"]},{"title":"如何应对接口机故障","url":"/2019/11/04/%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E6%8E%A5%E5%8F%A3%E7%BA%A7%E6%95%85%E9%9A%9C/","content":"<ul>\n<li>接口级故障的典型表现就是系统并没有宕机，网络也没有中断，但业务却出现了问题。例<br>如，业务响应缓慢、大量访问超时、大量访问出现异常（给用户弹出提示“无法连接数据<br>库”），这类问题的主要原因在于系统压力过大、负载太高，导致无法快速处理业务请求，<br>由此引发更多的后续问题。例如，最常见的数据库慢查询将数据库的服务器资源耗尽，导致<br>读写超时，业务读写数据库时要么无法连接数据库、要么超时，最终用户看到的现象就是访<br>问很慢，一会访问抛出异常，一会访问又是正常结果。</li>\n</ul>\n<h2 id=\"导致接口级故障的原因一般有下面几种：\"><a href=\"#导致接口级故障的原因一般有下面几种：\" class=\"headerlink\" title=\"导致接口级故障的原因一般有下面几种：\"></a>导致接口级故障的原因一般有下面几种：</h2><h3 id=\"内部原因\"><a href=\"#内部原因\" class=\"headerlink\" title=\"内部原因\"></a>内部原因</h3><ul>\n<li>程序 bug 导致死循环，某个接口导致数据库慢查询，程序逻辑不完善导致耗尽内存等。</li>\n</ul>\n<h3 id=\"外部原因\"><a href=\"#外部原因\" class=\"headerlink\" title=\"外部原因\"></a>外部原因</h3><ul>\n<li>黑客攻击、促销或者抢购引入了超出平时几倍甚至几十倍的用户，第三方系统大量请求，第<br>三方系统响应缓慢等。</li>\n</ul>\n<h3 id=\"解决接口级故障的核心思想\"><a href=\"#解决接口级故障的核心思想\" class=\"headerlink\" title=\"解决接口级故障的核心思想\"></a>解决接口级故障的核心思想</h3><ul>\n<li>优先保证核心业务和优先保证绝大部分用户</li>\n</ul>\n<h2 id=\"降级\"><a href=\"#降级\" class=\"headerlink\" title=\"降级\"></a>降级</h2><ul>\n<li><p>降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所<br>有功能。例如，论坛可以降级为只能看帖子，不能发帖子；也可以降级为只能看帖子和评<br>论，不能发评论；而 App 的日志上传接口，可以完全停掉一段时间，这段时间内 App 都<br>不能上传日志。</p>\n</li>\n<li><p>降级的核心思想就是丢车保帅，优先保证核心业务。例如，对于论坛来说，90% 的流量是<br>看帖子，那我们就优先保证看帖的功能；对于一个 App 来说，日志上传接口只是一个辅助<br>的功能，故障时完全可以停掉。</p>\n</li>\n<li><p>常见的实现降级的方式有：<br>简单来说，就是系统预留了后门用于降级操作。例如，系统提供一个降级 URL，当访问这<br>个 URL 时，就相当于执行降级指令，具体的降级指令通过 URL 的参数传入即可。这种方<br>案有一定的安全隐患，所以也会在 URL 中加入密码这类安全措施。<br>系统后门降级的方式实现成本低，但主要缺点是如果服务器数量多，需要一台一台去操作，<br>效率比较低，这在故障处理争分夺秒的场景下是比较浪费时间的。</p>\n</li>\n</ul>\n<h2 id=\"熔断\"><a href=\"#熔断\" class=\"headerlink\" title=\"熔断\"></a>熔断</h2><ul>\n<li><p>熔断和降级是两个比较容易混淆的概念，因为单纯从名字上看好像都有禁止某个功能的意<br>思，但其实内在含义是不同的，原因在于降级的目的是应对系统自身的故障，而熔断的目的<br>是应对依赖的外部系统故障的情况。</p>\n</li>\n<li><p>假设一个这样的场景：A 服务的 X 功能依赖 B 服务的某个接口，当 B 服务的接口响应很慢<br>的时候，A 服务的 X 功能响应肯定也会被拖慢，进一步导致 A 服务的线程都被卡在 X 功能<br>处理上，此时 A 服务的其他功能都会被卡住或者响应非常慢。这时就需要熔断机制了，<br>即：A 服务不再请求 B 服务的这个接口，A 服务内部只要发现是请求 B 服务的这个接口就<br>立即返回错误，从而避免 A 服务整个被拖慢甚至拖死。</p>\n</li>\n<li><p>熔断机制实现的关键是需要有一个统一的 API 调用层，由 API 调用层来进行采样或者统<br>计，如果接口调用散落在代码各处就没法进行统一处理了。</p>\n</li>\n<li><p>熔断机制实现的另外一个关键是阈值的设计，例如 1 分钟内 30% 的请求响应时间超过 1<br>秒就熔断，这个策略中的“1 分钟”“30%”“1 秒”都对最终的熔断效果有影响。</p>\n</li>\n</ul>\n<h2 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h2><ul>\n<li><p>降级是从系统功能优先级的角度考虑如何应对故障，而限流则是从用户访问压力的角度来考<br>虑如何应对故障。限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被<br>丢弃。</p>\n</li>\n<li><p>虽然“丢弃”这个词听起来让人不太舒服，但保证一部分请求能够正常响应，总比全部请求<br>都不能响应要好得多。</p>\n</li>\n<li><p>限流一般都是系统内实现的，常见的限流方式可以分为两类：基于请求限流和基于资源限<br>流。</p>\n</li>\n<li><p>基于请求限流指从外部访问的请求角度考虑限流，常见的方式有：限制总量、限制时间量。<br>限制总量的方式是限制某个指标的累积上限，常见的是限制当前系统服务的用户总量，例如<br>某个直播间限制总用户数上限为 100 万，超过 100 万后新的用户无法进入；某个抢购活动<br>商品数量只有 100 个，限制参与抢购的用户上限为 1 万个，1 万以后的用户直接拒绝。限<br>制时间量指限制一段时间内某个指标的上限，例如，1 分钟内只允许 10000 个用户访问，<br>每秒请求峰值最高为 10 万。</p>\n</li>\n<li><p>无论是限制总量还是限制时间量，共同的特点都是实现简单，但在实践中面临的主要问题是<br>比较难以找到合适的阈值，例如系统设定了 1 分钟 10000 个用户，但实际上 6000 个用户<br>的时候系统就扛不住了；也可能达到 1 分钟 10000 用户后，其实系统压力还不大，但此时<br>已经开始丢弃用户访问了。</p>\n</li>\n<li><p>即使找到了合适的阈值，基于请求限流还面临硬件相关的问题。例如一台 32 核的机器和<br>64 核的机器处理能力差别很大，阈值是不同的，可能有的技术人员以为简单根据硬件指标<br>进行数学运算就可以得出来，实际上这样是不可行的，64 核的机器比 32 核的机器，业务<br>处理性能并不是 2 倍的关系，可能是 1.5 倍，甚至可能是 1.1 倍。</p>\n</li>\n<li><p>为了找到合理的阈值，通常情况下可以采用性能压测来确定阈值，但性能压测也存在覆盖场<br>景有限的问题，可能出现某个性能压测没有覆盖的功能导致系统压力很大；另外一种方式是<br>基于请求限流<br>限制总量的方式是限制某个指标的累积上限，常见的是限制当前系统服务的用户总量，例如<br>某个直播间限制总用户数上限为 100 万，超过 100 万后新的用户无法进入；某个抢购活动<br>商品数量只有 100 个，限制参与抢购的用户上限为 1 万个，1 万以后的用户直接拒绝。限<br>制时间量指限制一段时间内某个指标的上限，例如，1 分钟内只允许 10000 个用户访问，<br>每秒请求峰值最高为 10 万。</p>\n</li>\n</ul>\n<h2 id=\"排队\"><a href=\"#排队\" class=\"headerlink\" title=\"排队\"></a>排队</h2><ul>\n<li>排队实际上是限流的一个变种，限流是直接拒绝用户，排队是让用户等待一段时间，全世界<br>最有名的排队当属 12306 网站排队了。排队虽然没有直接拒绝用户，但用户等了很长时间<br>后进入系统，体验并不一定比限流好。</li>\n<li>由于排队需要临时缓存大量的业务请求，单个系统内部无法缓存这么多数据，一般情况下，<br>排队需要用独立的系统去实现。</li>\n</ul>\n","tags":["架构"]},{"title":"死锁发生条件及如何避免","url":"/2019/11/19/%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F%E6%9D%A1%E4%BB%B6%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D/","content":"<h1 id=\"死锁发生条件\"><a href=\"#死锁发生条件\" class=\"headerlink\" title=\"死锁发生条件\"></a>死锁发生条件</h1><ol>\n<li><p>互斥，共享资源 X 和 Y 只能被一个线程占用；</p>\n</li>\n<li><p>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资<br>源 X；</p>\n</li>\n<li><p>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</p>\n</li>\n<li><p>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是<br>循环等待。</p>\n</li>\n</ol>\n<h1 id=\"如何避免死锁\"><a href=\"#如何避免死锁\" class=\"headerlink\" title=\"如何避免死锁\"></a>如何避免死锁</h1><pre><code>只要破坏4个条件中的一个即可避免死锁。\n</code></pre>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"number\">1</span>. 对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待</span><br><span class=\"line\">了。</span><br><span class=\"line\"><span class=\"number\">2</span>. 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不</span><br><span class=\"line\">到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</span><br><span class=\"line\"><span class=\"number\">3</span>. 对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是</span><br><span class=\"line\">有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性</span><br><span class=\"line\">化后自然就不存在循环了。</span><br><span class=\"line\">我们已经从理论上解决了如何预防死锁，那具体如何体现在代码上呢？下面我们就来尝试用</span><br><span class=\"line\">代码实践一下这些理论。</span><br><span class=\"line\"><span class=\"number\">1</span>. 破坏占用且等待条件</span><br><span class=\"line\">从理论上讲，要破坏这个条件，可以一次性申请所有资源。在现实世界里，</span><br><span class=\"line\">转账操作，它需要的资源有两个，一个是转出账户，另一个是转入账户，当这两个</span><br><span class=\"line\">账户同时被申请时，我们该怎么解决这个问题呢？</span><br><span class=\"line\">可以增加一个账本管理员，然后只允许账本管理员从文件架上拿账本，也就是说柜员不能直</span><br><span class=\"line\">接在文件架上拿账本，必须通过账本管理员才能拿到想要的账本。例如，张三同时申请账本</span><br><span class=\"line\"><span class=\"selector-tag\">A</span> 和 <span class=\"selector-tag\">B</span>，账本管理员如果发现文件架上只有账本 <span class=\"selector-tag\">A</span>，这个时候账本管理员是不会把账本 <span class=\"selector-tag\">A</span></span><br><span class=\"line\">拿下来给张三的，只有账本 <span class=\"selector-tag\">A</span> 和 <span class=\"selector-tag\">B</span> 都在的时候才会给张三。这样就保证了“一次性申请所</span><br><span class=\"line\">有资源”。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"关于避免死锁\"><a href=\"#关于避免死锁\" class=\"headerlink\" title=\"关于避免死锁\"></a>关于避免死锁</h1><figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">1.</span> 避免滥用锁，程序里用的锁少，写出死锁 Bug 的几率自然就低。</span><br><span class=\"line\"><span class=\"bullet\">2.</span> 对于同一把锁，加锁和解锁必须要放在同一个方法中，这样一次加锁对应一次解锁，代</span><br><span class=\"line\">码清晰简单，便于分析问题。</span><br><span class=\"line\"><span class=\"bullet\">3.</span> 尽量避免在持有一把锁的情况下，去获取另外一把锁，就是要尽量避免同时持有多把</span><br><span class=\"line\">锁。</span><br><span class=\"line\"><span class=\"bullet\">4.</span> 如果需要持有多把锁，一定要注意加解锁的顺序，解锁的顺序要和加锁顺序相反。比</span><br><span class=\"line\">如，获取三把锁的顺序是 A、B、C，释放锁的顺序必须是 C、B、A。</span><br><span class=\"line\"><span class=\"bullet\">5.</span> 给你程序中所有的锁排一个顺序，在所有需要加锁的地方，按照同样的顺序加解锁。比</span><br><span class=\"line\">如我刚刚举的那个例子，如果两个线程都按照先获取 lockA 再获取 lockB 的顺序加</span><br><span class=\"line\">锁，就不会产生死锁。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","tags":["锁"]},{"title":"父子节点的List转 tree","url":"/2019/08/30/%E7%88%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84List%E8%BD%AC-tree/","content":"<blockquote>\n<p>摘要： 本文主要介绍父子节点的List转 tree</p>\n</blockquote>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>、构建tree</span><br><span class=\"line\"><span class=\"number\">2</span>、从数据库查询<span class=\"built_in\">list</span></span><br><span class=\"line\"><span class=\"number\">3</span>、将<span class=\"built_in\">list</span>转为tree</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 树节点实体类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">@Data</span><br><span class=\"line\">public <span class=\"keyword\">class</span> TreeNode implements Serializable &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> static final long serialVersionUID = <span class=\"number\">7297611707550474985L</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer parentId;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;TreeNode&gt; children;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic <span class=\"constructor\">TreeNode(String <span class=\"params\">id</span>, String <span class=\"params\">name</span>, String <span class=\"params\">parentId</span>)</span> &#123;</span><br><span class=\"line\">\t\tthis.id = id;</span><br><span class=\"line\">\t\tthis.parentId = parentId;</span><br><span class=\"line\">\t\tthis.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"comment\">// 根节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> final Integer PARENT_ID=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 方式一：使用for循环实现</span></span><br><span class=\"line\"><span class=\"comment\">\t * @param treeList</span></span><br><span class=\"line\"><span class=\"comment\">\t * @return</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;TreeNode&gt; loop<span class=\"constructor\">ToTree(List&lt;TreeNode&gt; <span class=\"params\">treeList</span>)</span> &#123;</span><br><span class=\"line\">\t\tList&lt;TreeNode&gt; resList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (TreeNode parent : treeList) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//添加根节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (PARENT_ID==parent.get<span class=\"constructor\">ParentId()</span>) &#123;</span><br><span class=\"line\">\t\t\t\tresList.add(parent);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//添加子节点</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (TreeNode child : treeList) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (child.get<span class=\"constructor\">ParentId()</span><span class=\"operator\"> == </span>parent.get<span class=\"constructor\">Id()</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (parent.get<span class=\"constructor\">Children()</span><span class=\"operator\"> == </span>null) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tparent.set<span class=\"constructor\">Children(<span class=\"params\">new</span> ArrayList&lt;&gt;()</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tparent.get<span class=\"constructor\">Children()</span>.add(child);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn resList;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 方式二：使用递归实现</span></span><br><span class=\"line\"><span class=\"comment\">\t * @param treeList</span></span><br><span class=\"line\"><span class=\"comment\">\t * @return</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span>  List&lt;TreeNode&gt; recursion<span class=\"constructor\">ToTree(List&lt;TreeNode&gt; <span class=\"params\">treeList</span>)</span> &#123;</span><br><span class=\"line\">\t\tList&lt;TreeNode&gt; resList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (TreeNode parent : treeList) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (PARENT_ID==parent.get<span class=\"constructor\">ParentId()</span>) &#123;</span><br><span class=\"line\">\t\t\t\tresList.add(find<span class=\"constructor\">Children(<span class=\"params\">parent</span>, <span class=\"params\">treeList</span>)</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn resList;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">private</span>  TreeNode find<span class=\"constructor\">Children(TreeNode <span class=\"params\">parent</span>, List&lt;TreeNode&gt; <span class=\"params\">treeList</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (TreeNode child : treeList) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (parent.get<span class=\"constructor\">Id()</span>.equals(child.get<span class=\"constructor\">ParentId()</span>)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (parent.get<span class=\"constructor\">Children()</span><span class=\"operator\"> == </span>null) &#123;</span><br><span class=\"line\">\t\t\t\t\tparent.set<span class=\"constructor\">Children(<span class=\"params\">new</span> ArrayList&lt;&gt;()</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tparent.get<span class=\"constructor\">Children()</span>.add(find<span class=\"constructor\">Children(<span class=\"params\">child</span>, <span class=\"params\">treeList</span>)</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn parent;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n","tags":["tree"]},{"title":"MQ如何保证消息不丢失","url":"/2023/09/14/MQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/","content":"<p><img src=\"/img/MQ%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF%E7%9A%843%E7%A7%8D%E5%9C%BA%E6%99%AF.jpg\"></p>\n<h1 id=\"Producer\"><a href=\"#Producer\" class=\"headerlink\" title=\"Producer\"></a>Producer</h1><p>生产者确认机制</p>\n<p>开启MQ确认机制，消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。</p>\n<p>消息失败之后如何处理呢？</p>\n<ul>\n<li>回调方法即时重发</li>\n<li>记录日志</li>\n<li>保存到数据库然后定时重发，成功发送后即刻删除表中的数据</li>\n</ul>\n<h1 id=\"Server\"><a href=\"#Server\" class=\"headerlink\" title=\"Server\"></a>Server</h1><p>消息持久化</p>\n<p>MQ开启持久化功能可以确保缓存在MQ中的消息不丢失</p>\n<p>交换机持久化 队列持久化 消息持久化</p>\n<h1 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h1><p>消费者处理消息后可以向MQ发送ack回执，MQ收到ack回执后才会删除该消息。</p>\n<figure class=\"highlight nsis\"><table><tr><td class=\"code\"><pre><span class=\"line\">manual：手动ack，需要在业务代码结束后，调用api发送ack。</span><br><span class=\"line\"><span class=\"literal\">auto</span>：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</span><br><span class=\"line\"><span class=\"literal\">none</span>：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</span><br></pre></td></tr></table></figure>\n\n<p>多次重试失败后将消息投递到异常交换机，交由人工处理</p>\n","tags":["MQ"]}]