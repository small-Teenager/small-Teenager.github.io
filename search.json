[{"title":"【短信验证】短信验证码流程","url":"%2F2018%2F12%2F20%2F%E3%80%90%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E3%80%91%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0%2F","content":"> 摘要： 本文主要介绍短信验证码。\n\n1.为什么需要验证码\n-----------------\n\n短信验证码用于保护网站。试想一下，如果有人使用作弊设备，在您的网站上多次注册，登录，发布和评论不仅会严重影响网站的运行，导致网站缓慢打开，还会导致大量垃圾内容，这将不可避免地导致网站体验。如果平台用户的注册不再需要输入手机验证码，商务平台每天将受到不同的攻击，运营和维护成本将大幅增加，并且使用用户移动互联网将大大减少。垃圾邮件的影响和规模将无法预测。对于平台，服务器资源是有限的。如果有人恶意登录，或使用软件发送垃圾邮件，则会导致服务器崩溃并最终拖动平台。因此，在网站的操作中，需要添加短信验证码功能。\n\n其次，短信验证码是由商家向用户发出的用于验证身份的证书。短信验证码平台通过手机短信发送验证码，这是验证用户真实身份的最常用，最安全的方式。通过手机号码验证注册会员，您可以确认手机号码属于我。提高网站用户注册的质量，并可以更有效地管理网站的注册用户。通过手机验证码，商家可以更方便地获取用户信息，并与他们进行交互，随时与他们保持联系和沟通。第三，用户的手机号码也可以绑定，派生出更多的短信验证码应用。例如手机密码恢复，登录保护，交易确认，手机发送指令，手机账号和用户注册账号等可以同步登录，同步通讯录，同步更多手机相关应用。短信验证码的使用有效提高了用户账号的安全性，是电子商务和行业网站不可或缺的一部分。高质量的短信验证码对于改善用户体验具有不可替代的作用。\n\n\n2.短信验证流程\n----------------\n\n1、构造手机验证码，如生成一个6位的随机数字串；\n\n2、正则验证手机号，使用接口向短信平台发送手机号和验证码，然后短信平台再把验证码发送到指定的手机号上；\n\n3、将手机号、验证码、操作时间存入Session中，作为后面验证使用；\n\n4、接收用户填写的验证码、手机号及其他注册数据，提交；\n\n5、对比提交的验证码与Session中的验证码是否一致，同时判断提交动作是否在有效期内；\n\n6、验证码正确且在有效期内，请求通过，处理相应的业务\n\n","tags":["短信验证"]},{"title":"【Javaweb】购物车实现","url":"%2F2018%2F12%2F15%2F%E3%80%90Javaweb%E3%80%91%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%AE%9E%E7%8E%B0%2F","content":"\n1.购物车实现方式\n---------------------------\n1.用cookie实现购物车；\n\t\n2.用session实现购物车；\n\t\n3.用cookie和数据库(购物车信息持久化)实现购物车；\n\t\n----\n\t\n1.单纯有cookie实现购物车，这样的购物车不是很理想，设想一下，如果客户端的浏览器把cookie给禁用了...\n\n2.session中保存购物车的信息，这个只是在一个会话中可用，如果用户没有登录，或者说登录了以后，添加购物车，在关闭浏览器...\n\n2.分析\n---------------------------\n1、添加购物车不需要用户登录。购物车的数据应该放到cookie中。\n\n2、当向购物车添加同一款商品时，购物车中商品的数量增加。\n\n3、购物车中可以删除商品\n\n4、购物车中可以修改商品数量。商品的总价需要重新计算。\n\n5、点击“结算”按钮要求用户登录。\n\n3.实现\n---------------------------\nA.用户登录前的数据流：用户在没有登录系统的时候，对喜欢的商品进行添加购物车，那么这个时候，我们可以把购物车信息保存到cookie中，这里会涉及到cookie的添加，修改操作；也即如果之前在cookie中不存对应的cookie，则就对cookie进行添加操作。\n\n如果在cookie中存在对应的cookie，那么，这时候，就要对cookie进行修改操作了(这里涉及到用户对同一个商品进行多次添加购物车的情况)。\n\nB.用户登录后的数据流：用户在登录后，系统首先做的第一件事就是去获取对应的cookies，如果存在相关的购物车cookies，那么就对该购物车信息进行相应用户User的持久化操作，要么添加，要么修改。（添加操作:该用户所对应的购物车如果没有相应的信息进行添加操作；修改操作：类似的，\n\n如果存在对应用户的购物车信息，就进行修改操作）。用户登录后，也可以进行购物车的添加操作，不过，这里不是添加到cookie中，而是直接持久化到数据库中。注：用户登录后的数据都是和数据库打交道。\n\n\n","tags":["cart"]},{"title":"【Java】线程","url":"%2F2018%2F12%2F15%2F%E3%80%90Java%E3%80%91%E7%BA%BF%E7%A8%8B%2F","content":"\n> 摘要：主要介绍线程\n\n1.进程和线程的区别\n----------------\n进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资\n源分配和调度的一个独立单位。\n\t\n线程是进程的一个实体，是CPU 调度和分派的基本单位，他是比进程更小的能独立运\n行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如\n程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；\n\t\n>1.1进程和线程的关系：\n----------------\n①一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。\n\n②资源分配给进程，同一进程的所有线程共享该进程的所有资源。\n\n③线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。\n\n④处理机分给线程，即真正在处理机上运行的是线程。\n\n⑤线程是指进程内的一个执行单元，也是进程内的可调度实体。\n\n>1.2线程与进程的区别：\n----------------\n\n①调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。\n\n②并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。\n\n③拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进\n\t程的资源。\n\t\n④系统开销：在创建或撤销进程的时候，由于系统都要为之分配和回收资源，导致系统的明\n\t显大于创建或撤销线程时的开销。但进程有独立的地址空间，进程崩溃后，在保护模式下不\n\t会对其他的进程产生影响，而线程只是一个进程中的不同的执行路径。线程有自己的堆栈和\n\t局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进\n\t程的程序要比多线程的程序健壮，但是在进程切换时，耗费的资源较大，效率要差些。\n\t线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有\n\t独立的内存单元，而多个线程共享内存，从而极大的提高了程序运行效率。\n\t线程在执行过程中，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出\n\t口。但是线程不能够独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制。\n\t从逻辑角度看，多线程的意义子啊与一个应用程序中，有多个执行部分可以同时执行。但操\n\t作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这\n\t就是进程和线程的重要区别。\n\t\n2.出现死锁的条件\n----------------\n出现死锁有4 个必要条件：\n\n①互斥：存在互斥使用的资源，也就是临界资源；\n\n②占有等待：拥有资源的进程都在等待另外的资源；\n\n③非剥夺：进行所占有的资源是不可剥夺使用的资源；\n\n④循环等待：都在相互等待资源。\n\t\n3.多线程中stop 为什么不合适\n----------------\n多线程之间一般是有联系的，若用stop 停止了线程，容易强行打断线程之间的联系，\n\t容易产生错误。\n4.Sleep 和wait 的区别\n----------------\n①sleep 是Thread 类中的，wait 是Object 中的；\n\n②sleep 会在指定时间之后自动唤醒，wait 需要其他线程调用notify 或者notifyAll 唤醒；\n\n③sleep 还有个最大的特点就是谁调用，谁睡觉，即使在a 类中调用b 的sleep 方法，实际上还是a 去睡觉。\n\n④wait 只能使用在同步控制方法或者同步控制块中使用，sleep 在任何地方都能被使用；\n\n⑤持有锁的线程执行sleep，不释放锁，持有锁的线程执行到wait（）时锁释放。\n5.线程的五个状态和特点\n----------------\n①新建状态(New)：新创建了一个线程对象。\n\n②就绪状态(Runnable)：线程对象创建后,其他线程调用了该对象的start()方法.该状态的线程位于可运行线程池中,变得可运行,等待获取CPU 的使用权.\n\n③运行状态(Running)：就绪状态的线程获取了CPU,执行程序代码.\n\n④阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU 使用权,暂时停止运行.\n\t直到线程进入就绪状态,才有机会转到运行状态.阻塞的情况分三种：A）等待阻塞：运行的线程执\n\t行wait()方法,JVM 会把该线程放入等待池中。B）同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用,则JVM 会把该线程放入锁池中。 C）其他阻塞：\n\t运行的线程执行sleep()或join()方法,或者发出了I/O 请求时,JVM 会把该线程置为阻塞状态.当sleep()状态超时 join()等待线程终止或者超时 或者I/O 处理完毕时,线程重新转入就绪状态.\n\n⑤死亡状态(Dead)：线程执行完了或者因异常退出了run()方法,该线程结束生命周\n期.\n\n\n\n\n6.线程的生命周期\n----------------\n\n![](/img/线程生命周期.jpg)\n\n7.什么情况下使用Thread 什么情况下使用Runnable\n----------------\n继承Thread 类：如果一个类有了父类，便无法再继承。实现Runnale：更灵活，没\n有单继承的局限。\t","tags":["thread"]},{"title":"【Java】开发过程中的内存溢出及解决办法","url":"%2F2018%2F12%2F15%2F%E3%80%90Java%E3%80%91%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F","content":"\n\n> 摘要： 本文主要是对开发过程中存在的内存溢出问题及解决办法。\n\n1.引起内存溢出的原因有很多种，常见如下：\n----------------\n1. 内存中加载的数据量过于庞大，如一次从库取出多数据;\n2. 集合类中有对对象的引用，使完后未清空，使得JVM 不能回收;\n3. 代码中存在死循环或循环产生过多重复的对象实体; \n4. 使用的 第三方软件中的BUG;\n5. 启动参数内存值设定的过小;\n\n2.内存溢出的解决方案： \n----------------\n\n第一步，修改 JVM 启动参数，直接增加内存。（-Xms,Xmx参数不要忘记加）\n\n第二步，检查错误日志，查看‘outOfMemory’错误前是否有其它异常或错误。\n\n第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。\n\n\n1. 检查对数据库询中，是否有一次获得全部的数据。一般来说如果一次取十万条记录到内存就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出现问题，上线后，数据库中数据增多，一次查询可能引起内存溢出。因此对于数据库查询尽可能采用分页的方式查询。\n2. 检查代码中是否有死循环或递归调用。\n3. 检查是否有大循环重复产生新对象实体。\n4. 检查List、Map 等集合对象是否有使用完后未清除的问题。List、Map 等集合对象会始终存有对对象的引用，使得这些对象不能被GC 回收。\n\n第四步，使用内存查看工具动态查看内存使用情况。\n\n```\n\n\n\n\n\n","tags":["Java"]},{"title":"【分布式】单点登录系统","url":"%2F2018%2F12%2F15%2F%E3%80%90SSO%E3%80%91%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F%2F","content":"> 摘要： 本文主要介绍单点登录系统。\n\n1.什么是单点登录系统\n----------------\nSSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。\n SSO单点登录系统就是使用redis模拟Session（Key-Value），实现Session的统一管理。\n\n2.创建单点登录系统\n----------------\n使用的技术：\n----------------\n1、Mybatis\n\n2、Spring\n\n3、Springmvc\n\n4、Jedis\n\n## 具体实现\nSSO表现层\n        定义了三个处理器，分别用于注册、登录、外部调用，查看用户登录状态：\t\n \t\n## 登录拦截器\n分析\n当用户提交订单时此时必须要求用户登录，可以使用拦截器来实现。\n拦截器的处理流程：\n----------------\n1、拦截请求url\n\n2、从cookie中取token\n\n3、如果没有toke跳转到登录页面。\n\n4、取到token，需要调用sso系统的服务查询用户信息。\n\n5、如果用户session已经过期，跳转到登录页面\n\n6、如果没有过期，放行。\n \t","tags":["SSO"]},{"title":"【分布式】分布式环境中三种Session管理方法的使用场景及优缺点","url":"%2F2018%2F10%2F14%2F%E3%80%90Session%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%B8%89%E7%A7%8DSession%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%2F","content":"\n在分布式环境，管理Session通常使用下面三种方式：\n\n一、Session Replication 方式管理 (即session复制)\n------------------------------------------------\n\n简介：将一台机器上的Session数据广播复制到集群中其余机器上\n\n使用场景：机器较少，网络流量较小\n\n优点：实现简单、配置较少、当网络中有机器Down掉时不影响用户访问\n\n缺点：广播式复制到其余机器有一定廷时，带来一定网络开销\n\n二、Session Sticky 方式管理\n---------------------------\n\n简介：即粘性Session、当用户访问集群中某台机器后，强制指定后续所有请求均落到此机器上\n\n使用场景：机器数适中、对稳定性要求不是非常苛刻\n\n优点：实现简单、配置方便、没有额外网络开销\n\n缺点：网络中有机器Down掉时、用户Session会丢失、容易造成单点故障\n\n三、缓存集中式管理\n------------------\n\n简介：将Session存入分布式缓存集群中的某台机器上，当用户访问不同节点时先从缓存中拿Session信息\n\n使用场景：集群中机器数多、网络环境复杂\n\n优点：可靠性好\n\n缺点：实现复杂、稳定性依赖于缓存的稳定性、Session信息放入缓存时要有合理的策略写入\n\n","tags":["Session"]}]